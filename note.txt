1.日志系统和配置系统的整合
对于配置系统，在log.yam作用的统一个格式是
logs:
   -name: root
    level: (debug,error,info...)
    formatter: '%d %T %t %T %F %T [%p] %T %f %T %l %T <%m> %n'
    appender: 
      -type: (StdoutAppender,FileAppender)
       level: (debug,info,error...)
       file: /home/admin/workSpace/log.txt
//以上是默认的格式，用户如果需要的话，可以在下面以上面那种方式进行添加或者修改

//2022.5.27
不要在头文件里面写函数的定义，除非将定义放在类里面或者是哟个inline关键字进行修饰，不然的话如果该头文件被多个源文件包含的话，就会造成该函数被编译多次
从而出现函数重定义的问题。
//2022.5.28
如果想要一个类不能够被拷贝的话，我们可以额外定义一个noncopyable的类型，将该类的默认构造和默认析构定义为default，然后将其他的拷贝构造、拷贝赋值、移动构造、移动赋值全部都声明为delete。然后我们将直接让不能够被拷贝的类继承noncopyalbe就行了
//2022.5.29
封装的互斥器不能够用在const成员函数内部，因为他涉及到修改类中的m_mutex这个成员变量，而const成员函数内部不能够修改没有用mutable修饰的成员变量
经测试，在平凡写的情况下下，自旋锁的效率比互斥锁高3-4倍，原子锁和自旋锁效率相当，但是还是考虑使用自旋锁好一点，因为自旋锁在尝试几次抢不到锁之后就会陷入睡眠，而原子锁会在while中一直尝试获取锁，从而使得CPU利用率降低
//2022.5.30
static成员函数中不能够访问类中非static的成员
static成员函数不能够使用const关键字来进行修饰
在宏定义中，表达式一定要使用()将他给括起来,否则非常容易出错！！！！！！！！！！！！
//2022.6.9
类中的非静态成员变量的初始化顺序应该按照他们的声明顺序在构造函数的成员初始化列表中进行初始化，否则编译期会进行警告甚至报错
//2022.6.16
socket在非阻塞的状态下，当调用connect向服务器请求建立连接时，连接可能不会立刻就建立成功，这个时候connect的返回值是-1并且error为EINPROGRESS。这个时候我们需要对该socket的写事件进行监听，如果发生了写事件并且通过getsocketpot检测到错误码是0时才能够确定连接是建立成功的，否则就是失败的
//2022.6.17
查看当前项目的代码量的shell命令是 find . -name "*.h" -or -name "*.cc" | xargs grep -v "^$" | wc -l
今天简单测试了一下性能，开五个线程将i加到1000000000,1秒不到就完成了，所以可以看出多协程的效率是真的吊
2022.6.18
今天看了一下大端序和小端序转换的问题，系统提供了额对应的宏给我判断当前系统使用的是大端序还是小端序，具体去看endian.h这个文件的定义
如果要我们自己首先大端序-小端序之间的转化的的话，这个就需要借助& 0xff来完成。0xff相当于是1111 1111，然后&运算符表示的是只有只有同为1的时候才会返回1，否则返回的是0
所以&0xff配合在一起可以对二进制数中的任何一部分进行裁剪
比如16位的大端序-小端序之间的转化方式为  ((t&0xff00) >> 8) | ((t&0xff) << 8) 

然后enable_if这个是c++11中的一个新的特性，它的底层实现其实就是一个结构体模板，实现如下:

template<bool Cond, typename T = void> struct enable_if {};

template<typename T> struct enable_if<true, T> { typedef T type; }

并且在C++中，当我们对一个重载函数进行调用的时候，编译期会尝试去推导所以的候选函数以确保得到一个最完美的匹配,并且在推导的过程中涉及到C++语言的一个属性，叫做SFINAE,它的作用就是在推导的过程中如果遇到了那种invalid argument or return type，就会直接将该函数从候选函数中进行删除，编译期不会报错

2022.6.24
C++中成员函数的const属性会影响到重载
判断当前主机字节序的方式就是
  int i=1;
  if((*(char*)&i) == 1){
      //小端序
  }else{
      //大端序
  }

在宏定义里面，如果我们需要查看某一个宏是否存在的话，使用的是defined，如defined.而如果我们要定义宏，使用的是define

2022.7.1日
有符号整形是以补码的形式存储在内存中的，正数的补码就是其二进制本身，而负数的补码是其二进制取反+1后的值，如-1，它对应的补码是1111 1111
无符号整型对于负数，会生成极大的数.无符号整型和有符号整型一起计算时，生成的结果是无符号的
有符号与无符号之间的转化方法具体可以查看bytearray里面的方式
然后bytearray中对于整型采用的压缩方式是protobuf中的varint压缩算法,该算法是用来对无符号整型进行压缩的，压缩的方式是从右往左依次拿到val的7bit的值，然后将该值的最高位设置为1,然后val右移7位，就这样一直到最后一个有效的字节(也就是最高位不等于1的字节).


2022.7.29
服务器框架支持websocket,websocket是一个新的协议，引入的原因是主要为了解决http协议单向的问题.因为对于http协议 1.0/1.1而言，服务器端只能够被动的接受客户端发送来的请求，然后像客户端返回响应，也就是没有请求就没有响应，这样就使得客户端如果想要话获取到服务器的某些资源需要进行轮询，而轮询的开销是比较大的,需要不断的建立TCP连接或者维持着一条TCP连接.websocket就不一样了，websocket支持服务器主动的向客户端返回资源
