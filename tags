!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
Adddress	address.h	/^class Adddress{$/;"	c	namespace:JKYi
Alloc	fiber.cc	/^   static void* Alloc(size_t size){$/;"	f	class:JKYi::MallocStackAllocator	access:public	signature:(size_t size)
Backtrace	util.cc	/^void Backtrace(std::vector<std::string>&bt,int size,int skip){$/;"	f	namespace:JKYi	signature:(std::vector<std::string>&bt,int size,int skip)
Backtrace	util.h	/^   void Backtrace(std::vector<std::string>&bt,int size=64,int skip=1);$/;"	p	namespace:JKYi	signature:(std::vector<std::string>&bt,int size=64,int skip=1)
BacktraceToString	util.cc	/^std::string BacktraceToString(int size,int skip,const std::string&prefix){$/;"	f	namespace:JKYi	signature:(int size,int skip,const std::string&prefix)
BacktraceToString	util.h	/^   std::string BacktraceToString(int size=64,int skip=2,const std::string&prefix="  ");$/;"	p	namespace:JKYi	signature:(int size=64,int skip=2,const std::string&prefix=”)
CASLock	mutex.h	/^   CASLock(){$/;"	f	class:JKYi::CASLock	access:public	signature:()
CASLock	mutex.h	/^class CASLock:Noncopyable{$/;"	c	namespace:JKYi	inherits:Noncopyable
CallerMainFunc	fiber.cc	/^void Fiber::CallerMainFunc(){$/;"	f	class:JKYi::Fiber	signature:()
CallerMainFunc	fiber.h	/^   static void CallerMainFunc();$/;"	p	class:JKYi::Fiber	access:public	signature:()
Comparator	timer.h	/^   struct Comparator{$/;"	s	class:JKYi::Timer	access:private
Config	config.h	/^class Config{$/;"	c	namespace:JKYi
ConfigVar	config.h	/^   ConfigVar(const std::string&name,const T&default_value,const std::string&description="")$/;"	f	class:JKYi::ConfigVar	access:public	signature:(const std::string&name,const T&default_value,const std::string&description=”)
ConfigVar	config.h	/^class ConfigVar:public ConfigVarBase{$/;"	c	namespace:JKYi	inherits:ConfigVarBase
ConfigVarBase	config.h	/^   ConfigVarBase(const std::string&name,const std::string&description="")$/;"	f	class:JKYi::ConfigVarBase	access:public	signature:(const std::string&name,const std::string&description=”)
ConfigVarBase	config.h	/^class ConfigVarBase{$/;"	c	namespace:JKYi
ConfigVarMap	config.h	/^    typedef std::map<std::string,ConfigVarBase::ptr> ConfigVarMap;$/;"	t	class:JKYi::Config	access:public
Create	address.h	/^	static Address::ptr Create(const sockaddr*addr,socklen_t addrlen);$/;"	p	class:JKYi::Adddress	access:public	signature:(const sockaddr*addr,socklen_t addrlen)
Create	address.h	/^	static IPAddress::ptr Create(const char*address,uint32_t port=0);$/;"	p	class:JKYi::IPAddress	access:public	signature:(const char*address,uint32_t port=0)
Create	address.h	/^	static IPv4Address::ptr Create(const char*addr,uint32_t port=0);$/;"	p	class:JKYi::IPv4Address	access:public	signature:(const char*addr,uint32_t port=0)
Create	address.h	/^	static IPv6Address::ptr Create(const char*address,uint16_t port=0);$/;"	p	class:JKYi::IPv6Address	access:public	signature:(const char*address,uint16_t port=0)
DEBUG	log.h	/^     DEBUG=1,$/;"	e	enum:JKYi::LogLevel::Level
DateTimeFormatItem	log.cc	/^    DateTimeFormatItem(const std::string& format = "%Y-%m-%d %H:%M:%S")$/;"	f	class:JKYi::DateTimeFormatItem	access:public	signature:(const std::string& format = ”)
DateTimeFormatItem	log.cc	/^class DateTimeFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
Dealloc	fiber.cc	/^   static void Dealloc(void *ptr,size_t size){$/;"	f	class:JKYi::MallocStackAllocator	access:public	signature:(void *ptr,size_t size)
ERROR	log.h	/^     ERROR=4,$/;"	e	enum:JKYi::LogLevel::Level
EXCEPT	fiber.h	/^	  EXCEPT\/\/ÂºÇÂ∏∏ÊÄÅ$/;"	e	enum:JKYi::Fiber::State
EXEC	fiber.h	/^	  EXEC,  \/\/ËøêË°åÊÄÅ$/;"	e	enum:JKYi::Fiber::State
ElapseFormatItem	log.cc	/^    ElapseFormatItem(const std::string&str=""){}$/;"	f	class:JKYi::ElapseFormatItem	access:public	signature:(const std::string&str=”)
ElapseFormatItem	log.cc	/^class ElapseFormatItem:public LogFormatter::FormatItem{$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
Event	iomanager.h	/^   enum Event{$/;"	g	class:JKYi::IOManager	access:public
EventContext	iomanager.h	/^	 struct EventContext{$/;"	s	struct:JKYi::IOManager::FdContext	access:public
FATAL	log.h	/^     FATAL=5$/;"	e	enum:JKYi::LogLevel::Level
FdContext	iomanager.h	/^   struct FdContext{$/;"	s	class:JKYi::IOManager	access:private
FdCtx	fdmanager.cc	/^FdCtx::FdCtx(int fd)$/;"	f	class:JKYi::FdCtx	signature:(int fd)
FdCtx	fdmanager.h	/^   FdCtx(int fd);$/;"	p	class:JKYi::FdCtx	access:public	signature:(int fd)
FdCtx	fdmanager.h	/^class FdCtx:public std::enable_shared_from_this<FdCtx>{	$/;"	c	namespace:JKYi	inherits:std::enable_shared_from_this
FdManager	fdmanager.cc	/^FdManager::FdManager(){$/;"	f	class:JKYi::FdManager	signature:()
FdManager	fdmanager.h	/^	FdManager();$/;"	p	class:JKYi::FdManager	access:public	signature:()
FdManager	fdmanager.h	/^class FdManager{$/;"	c	namespace:JKYi
FdMgr	fdmanager.h	/^typedef Singleton<FdManager> FdMgr;$/;"	t	namespace:JKYi
Fiber	fiber.cc	/^Fiber::Fiber(){$/;"	f	class:JKYi::Fiber	signature:()
Fiber	fiber.cc	/^Fiber::Fiber(std::function<void ()>cb,size_t stacksize,bool use_caller)$/;"	f	class:JKYi::Fiber	signature:(std::function<void ()>cb,size_t stacksize,bool use_caller)
Fiber	fiber.h	/^	Fiber(std::function<void ()>cb,size_t stacksize=0,bool use_caller=false);$/;"	p	class:JKYi::Fiber	access:public	signature:(std::function<void ()>cb,size_t stacksize=0,bool use_caller=false)
Fiber	fiber.h	/^    Fiber();$/;"	p	class:JKYi::Fiber	access:public	signature:()
Fiber	fiber.h	/^class Fiber:public std::enable_shared_from_this<Fiber>{$/;"	c	namespace:JKYi	inherits:std::enable_shared_from_this
FiberAndThread	scheduler.h	/^	 FiberAndThread()$/;"	f	struct:JKYi::Scheduler::FiberAndThread	access:public	signature:()
FiberAndThread	scheduler.h	/^	 FiberAndThread(Fiber::ptr * f,int thr)$/;"	f	struct:JKYi::Scheduler::FiberAndThread	access:public	signature:(Fiber::ptr * f,int thr)
FiberAndThread	scheduler.h	/^	 FiberAndThread(Fiber::ptr f,int thr)$/;"	f	struct:JKYi::Scheduler::FiberAndThread	access:public	signature:(Fiber::ptr f,int thr)
FiberAndThread	scheduler.h	/^	 FiberAndThread(std::function<void ()>*f,int thr)$/;"	f	struct:JKYi::Scheduler::FiberAndThread	access:public	signature:(std::function<void ()>*f,int thr)
FiberAndThread	scheduler.h	/^	 FiberAndThread(std::function<void ()>f,int thr)$/;"	f	struct:JKYi::Scheduler::FiberAndThread	access:public	signature:(std::function<void ()>f,int thr)
FiberAndThread	scheduler.h	/^  struct FiberAndThread{$/;"	s	class:JKYi::Scheduler	access:private
FiberIdFormatItem	log.cc	/^    FiberIdFormatItem(const std::string&str=""){}$/;"	f	class:JKYi::FiberIdFormatItem	access:public	signature:(const std::string&str=”)
FiberIdFormatItem	log.cc	/^class FiberIdFormatItem:public LogFormatter::FormatItem{$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
FileLogAppender	log.cc	/^FileLogAppender::FileLogAppender(const std::string&filename)$/;"	f	class:JKYi::FileLogAppender	signature:(const std::string&filename)
FileLogAppender	log.h	/^     FileLogAppender(const std::string& filename);$/;"	p	class:JKYi::FileLogAppender	access:public	signature:(const std::string& filename)
FileLogAppender	log.h	/^class FileLogAppender:public LogAppender{$/;"	c	namespace:JKYi	inherits:LogAppender
FilenameFormatItem	log.cc	/^    FilenameFormatItem(const std::string& str = "") {}$/;"	f	class:JKYi::FilenameFormatItem	access:public	signature:(const std::string& str = ”)
FilenameFormatItem	log.cc	/^class FilenameFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
FormatItem	log.h	/^    class FormatItem{$/;"	c	class:JKYi::LogFormatter	access:public
FromString	log.cc	/^ LogLevel::Level LogLevel::FromString(const std::string&str){$/;"	f	class:JKYi::LogLevel	signature:(const std::string&str)
FromString	log.h	/^   static LogLevel::Level FromString(const std::string&str);$/;"	p	class:JKYi::LogLevel	access:public	signature:(const std::string&str)
GetCurrentMS	util.cc	/^uint64_t GetCurrentMS(){$/;"	f	namespace:JKYi	signature:()
GetCurrentMS	util.h	/^   uint64_t GetCurrentMS();$/;"	p	namespace:JKYi	signature:()
GetCurrentUS	util.cc	/^uint64_t GetCurrentUS(){$/;"	f	namespace:JKYi	signature:()
GetCurrentUS	util.h	/^   uint64_t GetCurrentUS();$/;"	p	namespace:JKYi	signature:()
GetFiberId	fiber.cc	/^uint64_t Fiber::GetFiberId(){$/;"	f	class:JKYi::Fiber	signature:()
GetFiberId	fiber.h	/^   static uint64_t GetFiberId();$/;"	p	class:JKYi::Fiber	access:public	signature:()
GetFiberId	util.cc	/^u_int32_t GetFiberId(){$/;"	f	namespace:JKYi	signature:()
GetFiberId	util.h	/^   u_int32_t GetFiberId();$/;"	p	namespace:JKYi	signature:()
GetInstance	singleton.h	/^   static T* GetInstance(){$/;"	f	class:JKYi::Singleton	access:public	signature:()
GetInterfaceAddress	address.h	/^	static bool GetInterfaceAddress(std::multimap<std::string,std::pair<Address::ptr,uint32_t>>&result,int family=AF_INET);$/;"	p	class:JKYi::Adddress	access:public	signature:(std::multimap<std::string,std::pair<Address::ptr,uint32_t>>&result,int family=AF_INET)
GetInterfaceAddress	address.h	/^	static bool GetInterfaceAddress(std::vector<std::pair<Address::ptr,uint32_t>>&result,const std::string&iface,int family=AF_INET);$/;"	p	class:JKYi::Adddress	access:public	signature:(std::vector<std::pair<Address::ptr,uint32_t>>&result,const std::string&iface,int family=AF_INET)
GetMainFiber	scheduler.cc	/^Fiber* Scheduler::GetMainFiber(){$/;"	f	class:JKYi::Scheduler	signature:()
GetMainFiber	scheduler.h	/^   static Fiber* GetMainFiber();$/;"	p	class:JKYi::Scheduler	access:public	signature:()
GetName	thread.cc	/^const std::string& Thread::GetName(){$/;"	f	class:JKYi::Thread	signature:()
GetName	thread.h	/^   static const std::string& GetName();$/;"	p	class:JKYi::Thread	access:public	signature:()
GetThis	fiber.cc	/^Fiber::ptr Fiber::GetThis(){$/;"	f	class:JKYi::Fiber	signature:()
GetThis	fiber.h	/^   static Fiber::ptr GetThis();$/;"	p	class:JKYi::Fiber	access:public	signature:()
GetThis	iomanager.cc	/^IOManager* IOManager::GetThis(){$/;"	f	class:JKYi::IOManager	signature:()
GetThis	iomanager.h	/^   static IOManager* GetThis();$/;"	p	class:JKYi::IOManager	access:public	signature:()
GetThis	scheduler.cc	/^Scheduler* Scheduler::GetThis(){$/;"	f	class:JKYi::Scheduler	signature:()
GetThis	scheduler.h	/^   static Scheduler* GetThis();$/;"	p	class:JKYi::Scheduler	access:public	signature:()
GetThis	thread.cc	/^Thread* Thread::GetThis(){$/;"	f	class:JKYi::Thread	signature:()
GetThis	thread.h	/^   static Thread* GetThis();$/;"	p	class:JKYi::Thread	access:public	signature:()
GetThreadId	util.cc	/^pid_t GetThreadId(){$/;"	f	namespace:JKYi	signature:()
GetThreadId	util.h	/^   pid_t GetThreadId();  $/;"	p	namespace:JKYi	signature:()
HOLD	fiber.h	/^	  HOLD,  \/\/ÊåÇËµ∑ÊÄÅ$/;"	e	enum:JKYi::Fiber::State
HOOK_FUN	hook.cc	21;"	d	file:
INFO	log.h	/^     INFO=2,$/;"	e	enum:JKYi::LogLevel::Level
INIT	fiber.h	/^      INIT,   \/\/ÂàõÂª∫ÊÄÅ  $/;"	e	enum:JKYi::Fiber::State
IOManager	iomanager.cc	/^IOManager::IOManager(size_t threads,bool use_caller,const std::string&name)$/;"	f	class:JKYi::IOManager	signature:(size_t threads,bool use_caller,const std::string&name)
IOManager	iomanager.h	/^   IOManager(size_t threads=1,bool use_caller=true,const std::string&name="");$/;"	p	class:JKYi::IOManager	access:public	signature:(size_t threads=1,bool use_caller=true,const std::string&name=”)
IOManager	iomanager.h	/^class IOManager:public Scheduler,public TimerManager{$/;"	c	namespace:JKYi	inherits:Scheduler,TimerManager
IPAddress	address.h	/^class IPAddress:public Address{$/;"	c	namespace:JKYi	inherits:Address
IPv4Address	address.h	/^	IPv4Address(const sockaddr_in&addr);$/;"	p	class:JKYi::IPv4Address	access:public	signature:(const sockaddr_in&addr)
IPv4Address	address.h	/^	IPv4Address(uint32_t address=INADDR_ANY,uint16_t port=0);$/;"	p	class:JKYi::IPv4Address	access:public	signature:(uint32_t address=INADDR_ANY,uint16_t port=0)
IPv4Address	address.h	/^class IPv4Address:public IPAddress{$/;"	c	namespace:JKYi	inherits:IPAddress
IPv6Address	address.h	/^	IPv6Address();$/;"	p	class:JKYi::IPv6Address	access:public	signature:()
IPv6Address	address.h	/^	IPv6Address(const sockaddr_in6&address);$/;"	p	class:JKYi::IPv6Address	access:public	signature:(const sockaddr_in6&address)
IPv6Address	address.h	/^	IPv6Address(const uint8_t address[16],uint16_t port=0);$/;"	p	class:JKYi::IPv6Address	access:public	signature:(const uint8_t address[16],uint16_t port=0)
IPv6Address	address.h	/^class IPv6Address:public IPAddress{$/;"	c	namespace:JKYi	inherits:IPAddress
JKYI_ASSERT	macro.h	12;"	d
JKYI_ASSERT2	macro.h	22;"	d
JKYI_BUG_ENDIAN	endian.h	6;"	d
JKYI_BYTE_ORDER	endian.h	31;"	d
JKYI_BYTE_ORDER	endian.h	33;"	d
JKYI_LITTLE_ENDIAN	endian.h	5;"	d
JKYI_LOG_DEBUG	log.h	27;"	d
JKYI_LOG_ERROR	log.h	33;"	d
JKYI_LOG_FATAL	log.h	35;"	d
JKYI_LOG_INFO	log.h	29;"	d
JKYI_LOG_LEVEL	log.h	20;"	d
JKYI_LOG_NAME	log.h	39;"	d
JKYI_LOG_ROOT	log.h	37;"	d
JKYI_LOG_WARN	log.h	31;"	d
JKYi	address.h	/^namespace JKYi{$/;"	n
JKYi	config.cc	/^namespace JKYi{$/;"	n	file:
JKYi	config.h	/^namespace JKYi{$/;"	n
JKYi	endian.h	/^namespace JKYi{$/;"	n
JKYi	fdmanager.cc	/^namespace JKYi{$/;"	n	file:
JKYi	fdmanager.h	/^namespace JKYi{$/;"	n
JKYi	fiber.cc	/^namespace JKYi{$/;"	n	file:
JKYi	fiber.h	/^namespace JKYi{$/;"	n
JKYi	hook.cc	/^namespace JKYi{$/;"	n	file:
JKYi	hook.h	/^namespace JKYi{$/;"	n
JKYi	iomanager.cc	/^namespace JKYi{$/;"	n	file:
JKYi	iomanager.h	/^namespace JKYi{$/;"	n
JKYi	log.cc	/^namespace JKYi{$/;"	n	file:
JKYi	log.h	/^namespace JKYi{$/;"	n
JKYi	mutex.cc	/^namespace JKYi{$/;"	n	file:
JKYi	mutex.h	/^namespace JKYi{$/;"	n
JKYi	noncopyable.h	/^namespace JKYi{$/;"	n
JKYi	scheduler.cc	/^namespace JKYi{$/;"	n	file:
JKYi	scheduler.h	/^namespace JKYi{$/;"	n
JKYi	singleton.h	/^namespace JKYi{$/;"	n
JKYi	thread.cc	/^namespace JKYi{$/;"	n	file:
JKYi	thread.h	/^namespace JKYi{$/;"	n
JKYi	timer.cc	/^namespace JKYi{$/;"	n	file:
JKYi	timer.h	/^namespace JKYi{$/;"	n
JKYi	util.cc	/^namespace JKYi{$/;"	n	file:
JKYi	util.h	/^namespace JKYi{$/;"	n
JKYi::Adddress	address.h	/^class Adddress{$/;"	c	namespace:JKYi
JKYi::Adddress::Create	address.h	/^	static Address::ptr Create(const sockaddr*addr,socklen_t addrlen);$/;"	p	class:JKYi::Adddress	access:public	signature:(const sockaddr*addr,socklen_t addrlen)
JKYi::Adddress::GetInterfaceAddress	address.h	/^	static bool GetInterfaceAddress(std::multimap<std::string,std::pair<Address::ptr,uint32_t>>&result,int family=AF_INET);$/;"	p	class:JKYi::Adddress	access:public	signature:(std::multimap<std::string,std::pair<Address::ptr,uint32_t>>&result,int family=AF_INET)
JKYi::Adddress::GetInterfaceAddress	address.h	/^	static bool GetInterfaceAddress(std::vector<std::pair<Address::ptr,uint32_t>>&result,const std::string&iface,int family=AF_INET);$/;"	p	class:JKYi::Adddress	access:public	signature:(std::vector<std::pair<Address::ptr,uint32_t>>&result,const std::string&iface,int family=AF_INET)
JKYi::Adddress::Lookup	address.h	/^	static bool Lookup(std::vector<Address::ptr>&result,const std::string&host,int family=AF_INET,int type=0,int protocol);$/;"	p	class:JKYi::Adddress	access:public	signature:(std::vector<Address::ptr>&result,const std::string&host,int family=AF_INET,int type=0,int protocol)
JKYi::Adddress::LookupAny	address.h	/^	static Address::ptr LookupAny(const std::string&host,int family=AF_INET,int type=0,int protocol=0);$/;"	p	class:JKYi::Adddress	access:public	signature:(const std::string&host,int family=AF_INET,int type=0,int protocol=0)
JKYi::Adddress::LookupAnyIPAddress	address.h	/^	static std::shared_ptr<IPAddress> LookupAnyIPAddress(const std::string&host,int family=AF_INET,int type=0,int protocol=0);$/;"	p	class:JKYi::Adddress	access:public	signature:(const std::string&host,int family=AF_INET,int type=0,int protocol=0)
JKYi::Adddress::getAddr	address.h	/^	virtual const sockaddr* getAddr()const=0;$/;"	p	class:JKYi::Adddress	access:public	signature:() const
JKYi::Adddress::getAddr	address.h	/^	virtual sockaddr* getAddr()=0;$/;"	p	class:JKYi::Adddress	access:public	signature:()
JKYi::Adddress::getAddrLen	address.h	/^	virtual socklen_t getAddrLen()const=0;$/;"	p	class:JKYi::Adddress	access:public	signature:() const
JKYi::Adddress::getFamily	address.h	/^	int getFamily()const;$/;"	p	class:JKYi::Adddress	access:public	signature:() const
JKYi::Adddress::insert	address.h	/^	virtual std::ostream& insert(std::ostream& os)const =0;$/;"	p	class:JKYi::Adddress	access:public	signature:(std::ostream& os) const
JKYi::Adddress::operator !=	address.h	/^   bool operator!= (const Address&rhv)const;$/;"	p	class:JKYi::Adddress	access:public	signature:(const Address&rhv) const
JKYi::Adddress::operator <	address.h	/^   bool operator< (const Address&rhv)const;$/;"	p	class:JKYi::Adddress	access:public	signature:(const Address&rhv) const
JKYi::Adddress::operator ==	address.h	/^   bool operator== (const Address&rhv)const;$/;"	p	class:JKYi::Adddress	access:public	signature:(const Address&rhv) const
JKYi::Adddress::ptr	address.h	/^	typedef std::shared_ptr<IPAddress> ptr;$/;"	t	class:JKYi::Adddress	access:public
JKYi::Adddress::toString	address.h	/^	std::string toString()const;$/;"	p	class:JKYi::Adddress	access:public	signature:() const
JKYi::Adddress::~Address	address.h	/^	virtual ~Address(){}$/;"	f	class:JKYi::Adddress	access:public	signature:()
JKYi::Backtrace	util.cc	/^void Backtrace(std::vector<std::string>&bt,int size,int skip){$/;"	f	namespace:JKYi	signature:(std::vector<std::string>&bt,int size,int skip)
JKYi::Backtrace	util.h	/^   void Backtrace(std::vector<std::string>&bt,int size=64,int skip=1);$/;"	p	namespace:JKYi	signature:(std::vector<std::string>&bt,int size=64,int skip=1)
JKYi::BacktraceToString	util.cc	/^std::string BacktraceToString(int size,int skip,const std::string&prefix){$/;"	f	namespace:JKYi	signature:(int size,int skip,const std::string&prefix)
JKYi::BacktraceToString	util.h	/^   std::string BacktraceToString(int size=64,int skip=2,const std::string&prefix="  ");$/;"	p	namespace:JKYi	signature:(int size=64,int skip=2,const std::string&prefix=”)
JKYi::CASLock	mutex.h	/^class CASLock:Noncopyable{$/;"	c	namespace:JKYi	inherits:Noncopyable
JKYi::CASLock::CASLock	mutex.h	/^   CASLock(){$/;"	f	class:JKYi::CASLock	access:public	signature:()
JKYi::CASLock::lock	mutex.h	/^   void lock(){$/;"	f	class:JKYi::CASLock	access:public	signature:()
JKYi::CASLock::m_mutex	mutex.h	/^   volatile std::atomic_flag m_mutex;$/;"	m	class:JKYi::CASLock	access:private
JKYi::CASLock::unlock	mutex.h	/^   void unlock(){$/;"	f	class:JKYi::CASLock	access:public	signature:()
JKYi::CASLock::~CASLock	mutex.h	/^   ~CASLock(){$/;"	f	class:JKYi::CASLock	access:public	signature:()
JKYi::Config	config.h	/^class Config{$/;"	c	namespace:JKYi
JKYi::Config::ConfigVarMap	config.h	/^    typedef std::map<std::string,ConfigVarBase::ptr> ConfigVarMap;$/;"	t	class:JKYi::Config	access:public
JKYi::Config::LoadFromYaml	config.cc	/^void Config::LoadFromYaml(const YAML::Node&node){$/;"	f	class:JKYi::Config	signature:(const YAML::Node&node)
JKYi::Config::LoadFromYaml	config.h	/^    static void LoadFromYaml(const YAML::Node&node);$/;"	p	class:JKYi::Config	access:public	signature:(const YAML::Node&node)
JKYi::Config::Lookup	config.h	/^    static typename ConfigVar<T>::ptr Lookup(const std::string&name){$/;"	f	class:JKYi::Config	access:public	signature:(const std::string&name)
JKYi::Config::Lookup	config.h	/^    static typename ConfigVar<T>::ptr Lookup(const std::string&name,$/;"	f	class:JKYi::Config	access:public	signature:(const std::string&name, const T&default_value,const std::string&description=”)
JKYi::Config::LookupBase	config.cc	/^ConfigVarBase::ptr Config::LookupBase(const std::string&name){$/;"	f	class:JKYi::Config	signature:(const std::string&name)
JKYi::Config::LookupBase	config.h	/^    static ConfigVarBase::ptr LookupBase(const std::string&name);$/;"	p	class:JKYi::Config	access:public	signature:(const std::string&name)
JKYi::Config::RWMutexType	config.h	/^	typedef RWMutex RWMutexType;$/;"	t	class:JKYi::Config	access:public
JKYi::Config::Visit	config.cc	/^void Config::Visit(std::function<void (ConfigVarBase::ptr)>cb){$/;"	f	class:JKYi::Config	signature:(std::function<void (ConfigVarBase::ptr)>cb)
JKYi::Config::Visit	config.h	/^	static void Visit(std::function<void (ConfigVarBase::ptr)>cb); $/;"	p	class:JKYi::Config	access:public	signature:(std::function<void (ConfigVarBase::ptr)>cb)
JKYi::Config::getDatas	config.h	/^    static ConfigVarMap& getDatas(){$/;"	f	class:JKYi::Config	access:private	signature:()
JKYi::Config::getMutex	config.h	/^	static RWMutexType& getMutex(){$/;"	f	class:JKYi::Config	access:private	signature:()
JKYi::ConfigVar	config.h	/^class ConfigVar:public ConfigVarBase{$/;"	c	namespace:JKYi	inherits:ConfigVarBase
JKYi::ConfigVar::ConfigVar	config.h	/^   ConfigVar(const std::string&name,const T&default_value,const std::string&description="")$/;"	f	class:JKYi::ConfigVar	access:public	signature:(const std::string&name,const T&default_value,const std::string&description=”)
JKYi::ConfigVar::RWMutexType	config.h	/^   typedef RWMutex RWMutexType;$/;"	t	class:JKYi::ConfigVar	access:public
JKYi::ConfigVar::addListener	config.h	/^   uint64_t addListener(on_change_cb cb){$/;"	f	class:JKYi::ConfigVar	access:public	signature:(on_change_cb cb)
JKYi::ConfigVar::clearListener	config.h	/^   void clearListener(){$/;"	f	class:JKYi::ConfigVar	access:public	signature:()
JKYi::ConfigVar::delListener	config.h	/^   void delListener(uint64_t key){$/;"	f	class:JKYi::ConfigVar	access:public	signature:(uint64_t key)
JKYi::ConfigVar::getListener	config.h	/^   on_change_cb getListener(uint64_t key){$/;"	f	class:JKYi::ConfigVar	access:public	signature:(uint64_t key)
JKYi::ConfigVar::getValue	config.h	/^   const T getValue(){$/;"	f	class:JKYi::ConfigVar	access:public	signature:()
JKYi::ConfigVar::m_cbs	config.h	/^   std::unordered_map<uint64_t,on_change_cb>m_cbs;$/;"	m	class:JKYi::ConfigVar	access:private
JKYi::ConfigVar::m_mutex	config.h	/^   RWMutexType m_mutex;$/;"	m	class:JKYi::ConfigVar	access:private
JKYi::ConfigVar::m_val	config.h	/^   T m_val;$/;"	m	class:JKYi::ConfigVar	access:private
JKYi::ConfigVar::on_change_cb	config.h	/^   typedef std::function<void (const  T&oldValue,const T&newValue)> on_change_cb;$/;"	t	class:JKYi::ConfigVar	access:public
JKYi::ConfigVar::ptr	config.h	/^   typedef std::shared_ptr<ConfigVar<T>> ptr;$/;"	t	class:JKYi::ConfigVar	access:public
JKYi::ConfigVar::setValue	config.h	/^   void setValue(const T&t){$/;"	f	class:JKYi::ConfigVar	access:public	signature:(const T&t)
JKYi::ConfigVarBase	config.h	/^class ConfigVarBase{$/;"	c	namespace:JKYi
JKYi::ConfigVarBase::ConfigVarBase	config.h	/^   ConfigVarBase(const std::string&name,const std::string&description="")$/;"	f	class:JKYi::ConfigVarBase	access:public	signature:(const std::string&name,const std::string&description=”)
JKYi::ConfigVarBase::fromString	config.h	/^   virtual bool fromString(const std::string&val)=0;$/;"	p	class:JKYi::ConfigVarBase	access:public	signature:(const std::string&val)
JKYi::ConfigVarBase::getDescription	config.h	/^   const std::string& getDescription()const {return m_description;}$/;"	f	class:JKYi::ConfigVarBase	access:public	signature:() const
JKYi::ConfigVarBase::getName	config.h	/^   const std::string& getName()const {return m_name;}$/;"	f	class:JKYi::ConfigVarBase	access:public	signature:() const
JKYi::ConfigVarBase::getType	config.h	/^   virtual std::string getType()const=0;$/;"	p	class:JKYi::ConfigVarBase	access:public	signature:() const
JKYi::ConfigVarBase::m_description	config.h	/^   std::string m_description;$/;"	m	class:JKYi::ConfigVarBase	access:private
JKYi::ConfigVarBase::m_name	config.h	/^   std::string m_name;$/;"	m	class:JKYi::ConfigVarBase	access:private
JKYi::ConfigVarBase::ptr	config.h	/^   typedef std::shared_ptr<ConfigVarBase> ptr;$/;"	t	class:JKYi::ConfigVarBase	access:public
JKYi::ConfigVarBase::toString	config.h	/^   virtual std::string toString()=0;$/;"	p	class:JKYi::ConfigVarBase	access:public	signature:()
JKYi::ConfigVarBase::~ConfigVarBase	config.h	/^   virtual ~ConfigVarBase(){};\/\/Âõ†‰∏∫Ë¶Å‰Ωú‰∏∫Âü∫Á±ª$/;"	f	class:JKYi::ConfigVarBase	access:public	signature:()
JKYi::DateTimeFormatItem	log.cc	/^class DateTimeFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
JKYi::DateTimeFormatItem::DateTimeFormatItem	log.cc	/^    DateTimeFormatItem(const std::string& format = "%Y-%m-%d %H:%M:%S")$/;"	f	class:JKYi::DateTimeFormatItem	access:public	signature:(const std::string& format = ”)
JKYi::DateTimeFormatItem::m_format	log.cc	/^    std::string m_format;$/;"	m	class:JKYi::DateTimeFormatItem	file:	access:private
JKYi::ElapseFormatItem	log.cc	/^class ElapseFormatItem:public LogFormatter::FormatItem{$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
JKYi::ElapseFormatItem::ElapseFormatItem	log.cc	/^    ElapseFormatItem(const std::string&str=""){}$/;"	f	class:JKYi::ElapseFormatItem	access:public	signature:(const std::string&str=”)
JKYi::FdCtx	fdmanager.h	/^class FdCtx:public std::enable_shared_from_this<FdCtx>{	$/;"	c	namespace:JKYi	inherits:std::enable_shared_from_this
JKYi::FdCtx::FdCtx	fdmanager.cc	/^FdCtx::FdCtx(int fd)$/;"	f	class:JKYi::FdCtx	signature:(int fd)
JKYi::FdCtx::FdCtx	fdmanager.h	/^   FdCtx(int fd);$/;"	p	class:JKYi::FdCtx	access:public	signature:(int fd)
JKYi::FdCtx::getSysNonblock	fdmanager.h	/^   bool getSysNonblock()const {return m_sysNonblock;}$/;"	f	class:JKYi::FdCtx	access:public	signature:() const
JKYi::FdCtx::getTimeout	fdmanager.cc	/^uint64_t FdCtx::getTimeout(int type){$/;"	f	class:JKYi::FdCtx	signature:(int type)
JKYi::FdCtx::getTimeout	fdmanager.h	/^   uint64_t getTimeout(int type);$/;"	p	class:JKYi::FdCtx	access:public	signature:(int type)
JKYi::FdCtx::getUserNonblock	fdmanager.h	/^   bool getUserNonblock()const {return m_userNonblock;}$/;"	f	class:JKYi::FdCtx	access:public	signature:() const
JKYi::FdCtx::init	fdmanager.cc	/^bool FdCtx::init(){$/;"	f	class:JKYi::FdCtx	signature:()
JKYi::FdCtx::init	fdmanager.h	/^   bool init();$/;"	p	class:JKYi::FdCtx	access:private	signature:()
JKYi::FdCtx::isClose	fdmanager.h	/^   bool isClose()const {return m_isClosed;}$/;"	f	class:JKYi::FdCtx	access:public	signature:() const
JKYi::FdCtx::isInit	fdmanager.h	/^   bool isInit()const {return m_isInit;}$/;"	f	class:JKYi::FdCtx	access:public	signature:() const
JKYi::FdCtx::isSocket	fdmanager.h	/^   bool isSocket()const{return m_isSocket;}$/;"	f	class:JKYi::FdCtx	access:public	signature:() const
JKYi::FdCtx::m_fd	fdmanager.h	/^  int m_fd;$/;"	m	class:JKYi::FdCtx	access:private
JKYi::FdCtx::m_recvTimeout	fdmanager.h	/^  uint64_t m_recvTimeout;$/;"	m	class:JKYi::FdCtx	access:private
JKYi::FdCtx::m_sendTimeout	fdmanager.h	/^  uint64_t m_sendTimeout;$/;"	m	class:JKYi::FdCtx	access:private
JKYi::FdCtx::ptr	fdmanager.h	/^   typedef std::shared_ptr<FdCtx> ptr;$/;"	t	class:JKYi::FdCtx	access:public
JKYi::FdCtx::setSysNonblock	fdmanager.h	/^   void setSysNonblock(bool flag) {m_sysNonblock=flag;}$/;"	f	class:JKYi::FdCtx	access:public	signature:(bool flag)
JKYi::FdCtx::setTimeout	fdmanager.cc	/^void FdCtx::setTimeout(int type,uint64_t t){$/;"	f	class:JKYi::FdCtx	signature:(int type,uint64_t t)
JKYi::FdCtx::setTimeout	fdmanager.h	/^   void setTimeout(int type,uint64_t v);$/;"	p	class:JKYi::FdCtx	access:public	signature:(int type,uint64_t v)
JKYi::FdCtx::setUserNonblock	fdmanager.h	/^   void setUserNonblock(bool flag){m_userNonblock=flag;}$/;"	f	class:JKYi::FdCtx	access:public	signature:(bool flag)
JKYi::FdCtx::~FdCtx	fdmanager.cc	/^FdCtx::~FdCtx(){$/;"	f	class:JKYi::FdCtx	signature:()
JKYi::FdCtx::~FdCtx	fdmanager.h	/^   ~FdCtx();$/;"	p	class:JKYi::FdCtx	access:public	signature:()
JKYi::FdManager	fdmanager.h	/^class FdManager{$/;"	c	namespace:JKYi
JKYi::FdManager::FdManager	fdmanager.cc	/^FdManager::FdManager(){$/;"	f	class:JKYi::FdManager	signature:()
JKYi::FdManager::FdManager	fdmanager.h	/^	FdManager();$/;"	p	class:JKYi::FdManager	access:public	signature:()
JKYi::FdManager::RWMutexType	fdmanager.h	/^    typedef RWMutex RWMutexType;$/;"	t	class:JKYi::FdManager	access:public
JKYi::FdManager::del	fdmanager.cc	/^void FdManager::del(int fd){$/;"	f	class:JKYi::FdManager	signature:(int fd)
JKYi::FdManager::del	fdmanager.h	/^	void del(int fd);$/;"	p	class:JKYi::FdManager	access:public	signature:(int fd)
JKYi::FdManager::get	fdmanager.cc	/^FdCtx::ptr FdManager::get(int fd,bool auto_create){$/;"	f	class:JKYi::FdManager	signature:(int fd,bool auto_create)
JKYi::FdManager::get	fdmanager.h	/^	FdCtx::ptr get(int fd,bool auto_create=false);$/;"	p	class:JKYi::FdManager	access:public	signature:(int fd,bool auto_create=false)
JKYi::FdManager::m_datas	fdmanager.h	/^	std::vector<FdCtx::ptr>m_datas;$/;"	m	class:JKYi::FdManager	access:private
JKYi::FdManager::m_mutex	fdmanager.h	/^    RWMutexType m_mutex; $/;"	m	class:JKYi::FdManager	access:private
JKYi::FdManager::~FdManager	fdmanager.cc	/^FdManager::~FdManager(){$/;"	f	class:JKYi::FdManager	signature:()
JKYi::FdManager::~FdManager	fdmanager.h	/^	~FdManager();$/;"	p	class:JKYi::FdManager	access:public	signature:()
JKYi::FdMgr	fdmanager.h	/^typedef Singleton<FdManager> FdMgr;$/;"	t	namespace:JKYi
JKYi::Fiber	fiber.h	/^class Fiber:public std::enable_shared_from_this<Fiber>{$/;"	c	namespace:JKYi	inherits:std::enable_shared_from_this
JKYi::Fiber::CallerMainFunc	fiber.cc	/^void Fiber::CallerMainFunc(){$/;"	f	class:JKYi::Fiber	signature:()
JKYi::Fiber::CallerMainFunc	fiber.h	/^   static void CallerMainFunc();$/;"	p	class:JKYi::Fiber	access:public	signature:()
JKYi::Fiber::EXCEPT	fiber.h	/^	  EXCEPT\/\/ÂºÇÂ∏∏ÊÄÅ$/;"	e	enum:JKYi::Fiber::State
JKYi::Fiber::EXEC	fiber.h	/^	  EXEC,  \/\/ËøêË°åÊÄÅ$/;"	e	enum:JKYi::Fiber::State
JKYi::Fiber::Fiber	fiber.cc	/^Fiber::Fiber(){$/;"	f	class:JKYi::Fiber	signature:()
JKYi::Fiber::Fiber	fiber.cc	/^Fiber::Fiber(std::function<void ()>cb,size_t stacksize,bool use_caller)$/;"	f	class:JKYi::Fiber	signature:(std::function<void ()>cb,size_t stacksize,bool use_caller)
JKYi::Fiber::Fiber	fiber.h	/^	Fiber(std::function<void ()>cb,size_t stacksize=0,bool use_caller=false);$/;"	p	class:JKYi::Fiber	access:public	signature:(std::function<void ()>cb,size_t stacksize=0,bool use_caller=false)
JKYi::Fiber::Fiber	fiber.h	/^    Fiber();$/;"	p	class:JKYi::Fiber	access:public	signature:()
JKYi::Fiber::GetFiberId	fiber.cc	/^uint64_t Fiber::GetFiberId(){$/;"	f	class:JKYi::Fiber	signature:()
JKYi::Fiber::GetFiberId	fiber.h	/^   static uint64_t GetFiberId();$/;"	p	class:JKYi::Fiber	access:public	signature:()
JKYi::Fiber::GetThis	fiber.cc	/^Fiber::ptr Fiber::GetThis(){$/;"	f	class:JKYi::Fiber	signature:()
JKYi::Fiber::GetThis	fiber.h	/^   static Fiber::ptr GetThis();$/;"	p	class:JKYi::Fiber	access:public	signature:()
JKYi::Fiber::HOLD	fiber.h	/^	  HOLD,  \/\/ÊåÇËµ∑ÊÄÅ$/;"	e	enum:JKYi::Fiber::State
JKYi::Fiber::INIT	fiber.h	/^      INIT,   \/\/ÂàõÂª∫ÊÄÅ  $/;"	e	enum:JKYi::Fiber::State
JKYi::Fiber::MainFunc	fiber.cc	/^void Fiber::MainFunc(){$/;"	f	class:JKYi::Fiber	signature:()
JKYi::Fiber::MainFunc	fiber.h	/^   static void MainFunc();$/;"	p	class:JKYi::Fiber	access:public	signature:()
JKYi::Fiber::READY	fiber.h	/^	  READY, \/\/Â∞±Áª™ÊÄÅ$/;"	e	enum:JKYi::Fiber::State
JKYi::Fiber::SetThis	fiber.cc	/^void Fiber::SetThis(Fiber*f){$/;"	f	class:JKYi::Fiber	signature:(Fiber*f)
JKYi::Fiber::SetThis	fiber.h	/^   static void SetThis(Fiber*f);$/;"	p	class:JKYi::Fiber	access:public	signature:(Fiber*f)
JKYi::Fiber::State	fiber.h	/^   enum State{$/;"	g	class:JKYi::Fiber	access:public
JKYi::Fiber::TERM	fiber.h	/^	  TERM,  \/\/ÁªìÊùüÊÄÅ$/;"	e	enum:JKYi::Fiber::State
JKYi::Fiber::TotalFibers	fiber.cc	/^uint64_t Fiber::TotalFibers(){$/;"	f	class:JKYi::Fiber	signature:()
JKYi::Fiber::TotalFibers	fiber.h	/^   static uint64_t TotalFibers();$/;"	p	class:JKYi::Fiber	access:public	signature:()
JKYi::Fiber::YieldToHold	fiber.cc	/^void Fiber::YieldToHold(){$/;"	f	class:JKYi::Fiber	signature:()
JKYi::Fiber::YieldToHold	fiber.h	/^   static void YieldToHold();$/;"	p	class:JKYi::Fiber	access:public	signature:()
JKYi::Fiber::YieldToReady	fiber.cc	/^void Fiber::YieldToReady(){$/;"	f	class:JKYi::Fiber	signature:()
JKYi::Fiber::YieldToReady	fiber.h	/^   static void YieldToReady();$/;"	p	class:JKYi::Fiber	access:public	signature:()
JKYi::Fiber::back	fiber.cc	/^void Fiber::back(){$/;"	f	class:JKYi::Fiber	signature:()
JKYi::Fiber::back	fiber.h	/^	void back();$/;"	p	class:JKYi::Fiber	access:public	signature:()
JKYi::Fiber::call	fiber.cc	/^void Fiber::call(){$/;"	f	class:JKYi::Fiber	signature:()
JKYi::Fiber::call	fiber.h	/^	void call();$/;"	p	class:JKYi::Fiber	access:public	signature:()
JKYi::Fiber::getId	fiber.h	/^	uint64_t getId()const {return m_id;}$/;"	f	class:JKYi::Fiber	access:public	signature:() const
JKYi::Fiber::getState	fiber.h	/^	State getState()const{return m_state;}$/;"	f	class:JKYi::Fiber	access:public	signature:() const
JKYi::Fiber::m_cb	fiber.h	/^   std::function<void ()>m_cb;$/;"	m	class:JKYi::Fiber	access:private
JKYi::Fiber::m_ctx	fiber.h	/^   ucontext_t m_ctx;$/;"	m	class:JKYi::Fiber	access:private
JKYi::Fiber::m_id	fiber.h	/^   uint64_t m_id=0;$/;"	m	class:JKYi::Fiber	access:private
JKYi::Fiber::m_stack	fiber.h	/^   void *m_stack=nullptr;$/;"	m	class:JKYi::Fiber	access:private
JKYi::Fiber::m_stacksize	fiber.h	/^   uint32_t m_stacksize=0;$/;"	m	class:JKYi::Fiber	access:private
JKYi::Fiber::m_state	fiber.h	/^   State m_state=INIT;$/;"	m	class:JKYi::Fiber	access:private
JKYi::Fiber::ptr	fiber.h	/^   typedef std::shared_ptr<Fiber> ptr;$/;"	t	class:JKYi::Fiber	access:public
JKYi::Fiber::reset	fiber.cc	/^void Fiber::reset(std::function<void()>cb){$/;"	f	class:JKYi::Fiber	signature:(std::function<void()>cb)
JKYi::Fiber::reset	fiber.h	/^	void reset(std::function<void ()>cb);$/;"	p	class:JKYi::Fiber	access:public	signature:(std::function<void ()>cb)
JKYi::Fiber::swapIn	fiber.cc	/^void Fiber::swapIn(){$/;"	f	class:JKYi::Fiber	signature:()
JKYi::Fiber::swapIn	fiber.h	/^	void swapIn();$/;"	p	class:JKYi::Fiber	access:public	signature:()
JKYi::Fiber::swapOut	fiber.cc	/^void Fiber::swapOut(){$/;"	f	class:JKYi::Fiber	signature:()
JKYi::Fiber::swapOut	fiber.h	/^	void swapOut();$/;"	p	class:JKYi::Fiber	access:public	signature:()
JKYi::Fiber::~Fiber	fiber.cc	/^Fiber::~Fiber(){$/;"	f	class:JKYi::Fiber	signature:()
JKYi::Fiber::~Fiber	fiber.h	/^	~Fiber();$/;"	p	class:JKYi::Fiber	access:public	signature:()
JKYi::FiberIdFormatItem	log.cc	/^class FiberIdFormatItem:public LogFormatter::FormatItem{$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
JKYi::FiberIdFormatItem::FiberIdFormatItem	log.cc	/^    FiberIdFormatItem(const std::string&str=""){}$/;"	f	class:JKYi::FiberIdFormatItem	access:public	signature:(const std::string&str=”)
JKYi::FileLogAppender	log.h	/^class FileLogAppender:public LogAppender{$/;"	c	namespace:JKYi	inherits:LogAppender
JKYi::FileLogAppender::FileLogAppender	log.cc	/^FileLogAppender::FileLogAppender(const std::string&filename)$/;"	f	class:JKYi::FileLogAppender	signature:(const std::string&filename)
JKYi::FileLogAppender::FileLogAppender	log.h	/^     FileLogAppender(const std::string& filename);$/;"	p	class:JKYi::FileLogAppender	access:public	signature:(const std::string& filename)
JKYi::FileLogAppender::log	log.cc	/^void FileLogAppender::log(std::shared_ptr<Logger>logger,LogLevel::Level level,LogEvent::ptr event){$/;"	f	class:JKYi::FileLogAppender	signature:(std::shared_ptr<Logger>logger,LogLevel::Level level,LogEvent::ptr event)
JKYi::FileLogAppender::m_filename	log.h	/^     std::string m_filename;\/\/Êñá‰ª∂Âêç$/;"	m	class:JKYi::FileLogAppender	access:private
JKYi::FileLogAppender::m_filestream	log.h	/^     std::ofstream m_filestream;$/;"	m	class:JKYi::FileLogAppender	access:private
JKYi::FileLogAppender::m_lastTime	log.h	/^	 uint64_t m_lastTime=0;\/\/ËÆ∞ÂΩï‰∏ä‰∏ÄÊ¨°ÊâìÂºÄÁöÑÊó∂Èó¥$/;"	m	class:JKYi::FileLogAppender	access:private
JKYi::FileLogAppender::override	log.h	/^     std::string toYamlString()override;$/;"	m	class:JKYi::FileLogAppender	access:public
JKYi::FileLogAppender::override	log.h	/^     void log(Logger::ptr logger, LogLevel::Level level, LogEvent::ptr event) override;$/;"	m	class:JKYi::FileLogAppender	access:public
JKYi::FileLogAppender::ptr	log.h	/^     typedef std::shared_ptr<FileLogAppender> ptr;$/;"	t	class:JKYi::FileLogAppender	access:public
JKYi::FileLogAppender::reopen	log.cc	/^bool FileLogAppender::reopen(){$/;"	f	class:JKYi::FileLogAppender	signature:()
JKYi::FileLogAppender::reopen	log.h	/^     bool reopen();\/\/ÈáçÊñ∞ÂØπÊñá‰ª∂ËøõË°åÊâìÂºÄÔºåÊâìÂºÄÊàêÂäüËøîÂõûtrue$/;"	p	class:JKYi::FileLogAppender	access:public	signature:()
JKYi::FileLogAppender::toYamlString	log.cc	/^std::string FileLogAppender::toYamlString(){$/;"	f	class:JKYi::FileLogAppender	signature:()
JKYi::FilenameFormatItem	log.cc	/^class FilenameFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
JKYi::FilenameFormatItem::FilenameFormatItem	log.cc	/^    FilenameFormatItem(const std::string& str = "") {}$/;"	f	class:JKYi::FilenameFormatItem	access:public	signature:(const std::string& str = ”)
JKYi::GetCurrentMS	util.cc	/^uint64_t GetCurrentMS(){$/;"	f	namespace:JKYi	signature:()
JKYi::GetCurrentMS	util.h	/^   uint64_t GetCurrentMS();$/;"	p	namespace:JKYi	signature:()
JKYi::GetCurrentUS	util.cc	/^uint64_t GetCurrentUS(){$/;"	f	namespace:JKYi	signature:()
JKYi::GetCurrentUS	util.h	/^   uint64_t GetCurrentUS();$/;"	p	namespace:JKYi	signature:()
JKYi::GetFiberId	util.cc	/^u_int32_t GetFiberId(){$/;"	f	namespace:JKYi	signature:()
JKYi::GetFiberId	util.h	/^   u_int32_t GetFiberId();$/;"	p	namespace:JKYi	signature:()
JKYi::GetThreadId	util.cc	/^pid_t GetThreadId(){$/;"	f	namespace:JKYi	signature:()
JKYi::GetThreadId	util.h	/^   pid_t GetThreadId();  $/;"	p	namespace:JKYi	signature:()
JKYi::IOManager	iomanager.h	/^class IOManager:public Scheduler,public TimerManager{$/;"	c	namespace:JKYi	inherits:Scheduler,TimerManager
JKYi::IOManager::Event	iomanager.h	/^   enum Event{$/;"	g	class:JKYi::IOManager	access:public
JKYi::IOManager::FdContext	iomanager.h	/^   struct FdContext{$/;"	s	class:JKYi::IOManager	access:private
JKYi::IOManager::FdContext::EventContext	iomanager.h	/^	 struct EventContext{$/;"	s	struct:JKYi::IOManager::FdContext	access:public
JKYi::IOManager::FdContext::EventContext::cb	iomanager.h	/^	   std::function<void ()>cb;$/;"	m	struct:JKYi::IOManager::FdContext::EventContext	access:public
JKYi::IOManager::FdContext::EventContext::fiber	iomanager.h	/^	   Fiber::ptr fiber;$/;"	m	struct:JKYi::IOManager::FdContext::EventContext	access:public
JKYi::IOManager::FdContext::EventContext::scheduler	iomanager.h	/^       Scheduler* scheduler=nullptr;$/;"	m	struct:JKYi::IOManager::FdContext::EventContext	access:public
JKYi::IOManager::FdContext::MutexType	iomanager.h	/^     typedef Mutex MutexType;$/;"	t	struct:JKYi::IOManager::FdContext	access:public
JKYi::IOManager::FdContext::events	iomanager.h	/^	 Event events=NONE;$/;"	m	struct:JKYi::IOManager::FdContext	access:public
JKYi::IOManager::FdContext::fd	iomanager.h	/^	 int fd=0;$/;"	m	struct:JKYi::IOManager::FdContext	access:public
JKYi::IOManager::FdContext::getContext	iomanager.cc	/^IOManager::FdContext::EventContext& IOManager::FdContext::getContext(IOManager::Event event){$/;"	f	class:JKYi::IOManager::FdContext	signature:(IOManager::Event event)
JKYi::IOManager::FdContext::getContext	iomanager.h	/^	 EventContext& getContext(Event event);$/;"	p	struct:JKYi::IOManager::FdContext	access:public	signature:(Event event)
JKYi::IOManager::FdContext::mutex	iomanager.h	/^	 MutexType mutex;$/;"	m	struct:JKYi::IOManager::FdContext	access:public
JKYi::IOManager::FdContext::read	iomanager.h	/^	 EventContext read;$/;"	m	struct:JKYi::IOManager::FdContext	access:public
JKYi::IOManager::FdContext::resetContext	iomanager.cc	/^void IOManager::FdContext::resetContext(EventContext&ctx){$/;"	f	class:JKYi::IOManager::FdContext	signature:(EventContext&ctx)
JKYi::IOManager::FdContext::resetContext	iomanager.h	/^	 void resetContext(EventContext&ctx);$/;"	p	struct:JKYi::IOManager::FdContext	access:public	signature:(EventContext&ctx)
JKYi::IOManager::FdContext::triggerEvent	iomanager.cc	/^void IOManager::FdContext::triggerEvent(IOManager::Event event){$/;"	f	class:JKYi::IOManager::FdContext	signature:(IOManager::Event event)
JKYi::IOManager::FdContext::triggerEvent	iomanager.h	/^	 void triggerEvent(Event event);$/;"	p	struct:JKYi::IOManager::FdContext	access:public	signature:(Event event)
JKYi::IOManager::FdContext::write	iomanager.h	/^	 EventContext write;$/;"	m	struct:JKYi::IOManager::FdContext	access:public
JKYi::IOManager::GetThis	iomanager.cc	/^IOManager* IOManager::GetThis(){$/;"	f	class:JKYi::IOManager	signature:()
JKYi::IOManager::GetThis	iomanager.h	/^   static IOManager* GetThis();$/;"	p	class:JKYi::IOManager	access:public	signature:()
JKYi::IOManager::IOManager	iomanager.cc	/^IOManager::IOManager(size_t threads,bool use_caller,const std::string&name)$/;"	f	class:JKYi::IOManager	signature:(size_t threads,bool use_caller,const std::string&name)
JKYi::IOManager::IOManager	iomanager.h	/^   IOManager(size_t threads=1,bool use_caller=true,const std::string&name="");$/;"	p	class:JKYi::IOManager	access:public	signature:(size_t threads=1,bool use_caller=true,const std::string&name=”)
JKYi::IOManager::NONE	iomanager.h	/^	   NONE  =  0x0,$/;"	e	enum:JKYi::IOManager::Event
JKYi::IOManager::READ	iomanager.h	/^	   READ  =  0x1,$/;"	e	enum:JKYi::IOManager::Event
JKYi::IOManager::RWMutexType	iomanager.h	/^   typedef RWMutex RWMutexType;$/;"	t	class:JKYi::IOManager	access:public
JKYi::IOManager::WRITE	iomanager.h	/^	   WRITE =  0x4$/;"	e	enum:JKYi::IOManager::Event
JKYi::IOManager::addEvent	iomanager.cc	/^int IOManager::addEvent(int fd,Event event,std::function<void()>cb){$/;"	f	class:JKYi::IOManager	signature:(int fd,Event event,std::function<void()>cb)
JKYi::IOManager::addEvent	iomanager.h	/^   int addEvent(int fd,Event event,std::function<void ()>cb=nullptr);$/;"	p	class:JKYi::IOManager	access:public	signature:(int fd,Event event,std::function<void ()>cb=nullptr)
JKYi::IOManager::cancelAll	iomanager.cc	/^bool IOManager::cancelAll(int fd){$/;"	f	class:JKYi::IOManager	signature:(int fd)
JKYi::IOManager::cancelAll	iomanager.h	/^   bool cancelAll(int fd);$/;"	p	class:JKYi::IOManager	access:public	signature:(int fd)
JKYi::IOManager::cancelEvent	iomanager.cc	/^bool IOManager::cancelEvent(int fd,Event event){$/;"	f	class:JKYi::IOManager	signature:(int fd,Event event)
JKYi::IOManager::cancelEvent	iomanager.h	/^   bool cancelEvent(int fd,Event event);$/;"	p	class:JKYi::IOManager	access:public	signature:(int fd,Event event)
JKYi::IOManager::contextResize	iomanager.cc	/^void IOManager::contextResize(size_t size){$/;"	f	class:JKYi::IOManager	signature:(size_t size)
JKYi::IOManager::contextResize	iomanager.h	/^   void contextResize(size_t size);$/;"	p	class:JKYi::IOManager	access:protected	signature:(size_t size)
JKYi::IOManager::delEvent	iomanager.cc	/^bool IOManager::delEvent(int fd,Event event){$/;"	f	class:JKYi::IOManager	signature:(int fd,Event event)
JKYi::IOManager::delEvent	iomanager.h	/^   bool delEvent(int fd,Event event);$/;"	p	class:JKYi::IOManager	access:public	signature:(int fd,Event event)
JKYi::IOManager::idle	iomanager.cc	/^void IOManager::idle(){$/;"	f	class:JKYi::IOManager	signature:()
JKYi::IOManager::m_epfd	iomanager.h	/^   int m_epfd=0;$/;"	m	class:JKYi::IOManager	access:private
JKYi::IOManager::m_fdContexts	iomanager.h	/^   std::vector<FdContext*>m_fdContexts;$/;"	m	class:JKYi::IOManager	access:private
JKYi::IOManager::m_mutex	iomanager.h	/^   RWMutexType m_mutex;$/;"	m	class:JKYi::IOManager	access:private
JKYi::IOManager::m_pendingEventCount	iomanager.h	/^   std::atomic<size_t>m_pendingEventCount={0};$/;"	m	class:JKYi::IOManager	access:private
JKYi::IOManager::m_tickleFds	iomanager.h	/^   int m_tickleFds[2];$/;"	m	class:JKYi::IOManager	access:private
JKYi::IOManager::onTimerInsertedAtFront	iomanager.cc	/^void IOManager::onTimerInsertedAtFront(){$/;"	f	class:JKYi::IOManager	signature:()
JKYi::IOManager::override	iomanager.h	/^   bool stopping()override;$/;"	m	class:JKYi::IOManager	access:protected
JKYi::IOManager::override	iomanager.h	/^   void idle()override;$/;"	m	class:JKYi::IOManager	access:protected
JKYi::IOManager::override	iomanager.h	/^   void onTimerInsertedAtFront()override;$/;"	m	class:JKYi::IOManager	access:protected
JKYi::IOManager::override	iomanager.h	/^   void tickle()override;$/;"	m	class:JKYi::IOManager	access:protected
JKYi::IOManager::ptr	iomanager.h	/^   typedef std::shared_ptr<IOManager> ptr;$/;"	t	class:JKYi::IOManager	access:public
JKYi::IOManager::stopping	iomanager.cc	/^bool IOManager::stopping(){$/;"	f	class:JKYi::IOManager	signature:()
JKYi::IOManager::stopping	iomanager.cc	/^bool IOManager::stopping(uint64_t &timeout){$/;"	f	class:JKYi::IOManager	signature:(uint64_t &timeout)
JKYi::IOManager::stopping	iomanager.h	/^   bool stopping(uint64_t&timeout);$/;"	p	class:JKYi::IOManager	access:protected	signature:(uint64_t&timeout)
JKYi::IOManager::tickle	iomanager.cc	/^void IOManager::tickle(){$/;"	f	class:JKYi::IOManager	signature:()
JKYi::IOManager::~IOManager	iomanager.cc	/^IOManager::~IOManager(){$/;"	f	class:JKYi::IOManager	signature:()
JKYi::IOManager::~IOManager	iomanager.h	/^   ~IOManager();    $/;"	p	class:JKYi::IOManager	access:public	signature:()
JKYi::IPAddress	address.h	/^class IPAddress:public Address{$/;"	c	namespace:JKYi	inherits:Address
JKYi::IPAddress::Create	address.h	/^	static IPAddress::ptr Create(const char*address,uint32_t port=0);$/;"	p	class:JKYi::IPAddress	access:public	signature:(const char*address,uint32_t port=0)
JKYi::IPAddress::broadcastAddress	address.h	/^	virtual IPAddress::ptr broadcastAddress(uint32_t prefix_len)=0;$/;"	p	class:JKYi::IPAddress	access:public	signature:(uint32_t prefix_len)
JKYi::IPAddress::getPort	address.h	/^	virtual uint32_t getPort()const =0;$/;"	p	class:JKYi::IPAddress	access:public	signature:() const
JKYi::IPAddress::networkAddress	address.h	/^	virtual IPAddress::ptr networkAddress(uint32_t prefix_len)=0;$/;"	p	class:JKYi::IPAddress	access:public	signature:(uint32_t prefix_len)
JKYi::IPAddress::ptr	address.h	/^	typedef std::shared_ptr<IPAddress> ptr;$/;"	t	class:JKYi::IPAddress	access:public
JKYi::IPAddress::setPort	address.h	/^	virtual void  setPort(uint16_t v)=0;$/;"	p	class:JKYi::IPAddress	access:public	signature:(uint16_t v)
JKYi::IPAddress::subnetMask	address.h	/^	virtual IPAddress::ptr subnetMask(uint32_t prefix_len)=0;$/;"	p	class:JKYi::IPAddress	access:public	signature:(uint32_t prefix_len)
JKYi::IPv4Address	address.h	/^class IPv4Address:public IPAddress{$/;"	c	namespace:JKYi	inherits:IPAddress
JKYi::IPv4Address::Create	address.h	/^	static IPv4Address::ptr Create(const char*addr,uint32_t port=0);$/;"	p	class:JKYi::IPv4Address	access:public	signature:(const char*addr,uint32_t port=0)
JKYi::IPv4Address::IPv4Address	address.h	/^	IPv4Address(const sockaddr_in&addr);$/;"	p	class:JKYi::IPv4Address	access:public	signature:(const sockaddr_in&addr)
JKYi::IPv4Address::IPv4Address	address.h	/^	IPv4Address(uint32_t address=INADDR_ANY,uint16_t port=0);$/;"	p	class:JKYi::IPv4Address	access:public	signature:(uint32_t address=INADDR_ANY,uint16_t port=0)
JKYi::IPv4Address::m_addr	address.h	/^	sockaddr_in m_addr;$/;"	m	class:JKYi::IPv4Address	access:private
JKYi::IPv4Address::override	address.h	/^	IPAddress::ptr broadcastAddress(uint32_t prefix_len)override;$/;"	m	class:JKYi::IPv4Address	access:public
JKYi::IPv4Address::override	address.h	/^	IPAddress::ptr networkAddress(uint32_t prefix_len)override;$/;"	m	class:JKYi::IPv4Address	access:public
JKYi::IPv4Address::override	address.h	/^	IPAddress::ptr subnetMask(uint32_t prefix_len)override;$/;"	m	class:JKYi::IPv4Address	access:public
JKYi::IPv4Address::override	address.h	/^	const sockaddr* getAddr()const override;$/;"	m	class:JKYi::IPv4Address	access:public
JKYi::IPv4Address::override	address.h	/^	sockaddr* getAddr()override;$/;"	m	class:JKYi::IPv4Address	access:public
JKYi::IPv4Address::override	address.h	/^	socklen_t getAddrLen()const override;$/;"	m	class:JKYi::IPv4Address	access:public
JKYi::IPv4Address::override	address.h	/^	std::ostream& insert(std::ostream&os)const override;$/;"	m	class:JKYi::IPv4Address	access:public
JKYi::IPv4Address::override	address.h	/^	uint32_t getPort()const override;$/;"	m	class:JKYi::IPv4Address	access:public
JKYi::IPv4Address::override	address.h	/^	void setPort(uint16_t v)override;$/;"	m	class:JKYi::IPv4Address	access:public
JKYi::IPv4Address::ptr	address.h	/^	typedef std::shared_ptr<IPv4Address> ptr;$/;"	t	class:JKYi::IPv4Address	access:public
JKYi::IPv6Address	address.h	/^class IPv6Address:public IPAddress{$/;"	c	namespace:JKYi	inherits:IPAddress
JKYi::IPv6Address::Create	address.h	/^	static IPv6Address::ptr Create(const char*address,uint16_t port=0);$/;"	p	class:JKYi::IPv6Address	access:public	signature:(const char*address,uint16_t port=0)
JKYi::IPv6Address::IPv6Address	address.h	/^	IPv6Address();$/;"	p	class:JKYi::IPv6Address	access:public	signature:()
JKYi::IPv6Address::IPv6Address	address.h	/^	IPv6Address(const sockaddr_in6&address);$/;"	p	class:JKYi::IPv6Address	access:public	signature:(const sockaddr_in6&address)
JKYi::IPv6Address::IPv6Address	address.h	/^	IPv6Address(const uint8_t address[16],uint16_t port=0);$/;"	p	class:JKYi::IPv6Address	access:public	signature:(const uint8_t address[16],uint16_t port=0)
JKYi::IPv6Address::m_addr	address.h	/^	sockaddr_in6 m_addr;$/;"	m	class:JKYi::IPv6Address	access:private
JKYi::IPv6Address::override	address.h	/^	IPAddress::ptr broadcastAddress(uint32_t prefix_len)override;$/;"	m	class:JKYi::IPv6Address	access:public
JKYi::IPv6Address::override	address.h	/^	IPAddress::ptr networkAddress(uint32_t prefix_len)override;$/;"	m	class:JKYi::IPv6Address	access:public
JKYi::IPv6Address::override	address.h	/^	IPAddress::ptr subnetMaskAddress(uint32_t predix_len)override;$/;"	m	class:JKYi::IPv6Address	access:public
JKYi::IPv6Address::override	address.h	/^	const sockaddr* getAddr()const override;$/;"	m	class:JKYi::IPv6Address	access:public
JKYi::IPv6Address::override	address.h	/^	sockaddr* getAddr()override;$/;"	m	class:JKYi::IPv6Address	access:public
JKYi::IPv6Address::override	address.h	/^	socklen_t getAddrLen()const override;$/;"	m	class:JKYi::IPv6Address	access:public
JKYi::IPv6Address::override	address.h	/^	std::ostream& insert(std::ostream&os)const override;$/;"	m	class:JKYi::IPv6Address	access:public
JKYi::IPv6Address::override	address.h	/^	void setPort(uint16_t v)override;$/;"	m	class:JKYi::IPv6Address	access:public
JKYi::IPv6Address::override	address.h	/^    uint32_t getPort()const override;$/;"	m	class:JKYi::IPv6Address	access:public
JKYi::IPv6Address::ptr	address.h	/^	typedef std::shadred_ptr<IPv6Address> ptr;$/;"	t	class:JKYi::IPv6Address	access:public
JKYi::LevelFormatItem	log.cc	/^class LevelFormatItem:public LogFormatter::FormatItem{$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
JKYi::LevelFormatItem::LevelFormatItem	log.cc	/^    LevelFormatItem(const std::string&str=""){}$/;"	f	class:JKYi::LevelFormatItem	access:public	signature:(const std::string&str=”)
JKYi::LexicalCast	config.h	/^class LexicalCast<std::list<T>,std::string>{$/;"	c	namespace:JKYi
JKYi::LexicalCast	config.h	/^class LexicalCast<std::map<std::string, T>, std::string> {$/;"	c	namespace:JKYi
JKYi::LexicalCast	config.h	/^class LexicalCast<std::set<T>,std::string>{$/;"	c	namespace:JKYi
JKYi::LexicalCast	config.h	/^class LexicalCast<std::string,std::list<T>>{$/;"	c	namespace:JKYi
JKYi::LexicalCast	config.h	/^class LexicalCast<std::string,std::map<std::string,T>>{$/;"	c	namespace:JKYi
JKYi::LexicalCast	config.h	/^class LexicalCast<std::string,std::set<T>>{$/;"	c	namespace:JKYi
JKYi::LexicalCast	config.h	/^class LexicalCast<std::string,std::unordered_map<std::string,T>>{$/;"	c	namespace:JKYi
JKYi::LexicalCast	config.h	/^class LexicalCast<std::string,std::unordered_set<T>>{$/;"	c	namespace:JKYi
JKYi::LexicalCast	config.h	/^class LexicalCast<std::string,std::vector<T>>{$/;"	c	namespace:JKYi
JKYi::LexicalCast	config.h	/^class LexicalCast<std::unordered_map<std::string, T>, std::string> {$/;"	c	namespace:JKYi
JKYi::LexicalCast	config.h	/^class LexicalCast<std::unordered_set<T>,std::string>{$/;"	c	namespace:JKYi
JKYi::LexicalCast	config.h	/^class LexicalCast<std::vector<T>,std::string>{$/;"	c	namespace:JKYi
JKYi::LexicalCast	config.h	/^class LexicalCast{$/;"	c	namespace:JKYi
JKYi::LexicalCast	log.cc	/^class LexicalCast<LogDefine,std::string>{$/;"	c	namespace:JKYi	file:
JKYi::LexicalCast	log.cc	/^class LexicalCast<std::string,LogDefine>{$/;"	c	namespace:JKYi	file:
JKYi::LexicalCast::operator ()	config.h	/^    std::string operator()(const std::map<std::string, T>& v) {$/;"	f	class:JKYi::LexicalCast	access:public	signature:(const std::map<std::string, T>& v)
JKYi::LexicalCast::operator ()	config.h	/^    std::string operator()(const std::unordered_map<std::string, T>& v) {$/;"	f	class:JKYi::LexicalCast	access:public	signature:(const std::unordered_map<std::string, T>& v)
JKYi::LexicalCast::operator ()	config.h	/^   T operator()(const F&f){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(const F&f)
JKYi::LexicalCast::operator ()	config.h	/^   std::list<T> operator()(const std::string&v){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(const std::string&v)
JKYi::LexicalCast::operator ()	config.h	/^   std::map<std::string,T> operator()(const std::string&v){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(const std::string&v)
JKYi::LexicalCast::operator ()	config.h	/^   std::set<T> operator()(const std::string&v){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(const std::string&v)
JKYi::LexicalCast::operator ()	config.h	/^   std::string operator()(std::list<T>&v){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(std::list<T>&v)
JKYi::LexicalCast::operator ()	config.h	/^   std::string operator()(std::set<T>&v){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(std::set<T>&v)
JKYi::LexicalCast::operator ()	config.h	/^   std::string operator()(std::unordered_set<T>&v){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(std::unordered_set<T>&v)
JKYi::LexicalCast::operator ()	config.h	/^   std::string operator()(std::vector<T>&v){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(std::vector<T>&v)
JKYi::LexicalCast::operator ()	config.h	/^   std::unordered_map<std::string,T> operator()(const std::string&v){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(const std::string&v)
JKYi::LexicalCast::operator ()	config.h	/^   std::unordered_set<T> operator()(const std::string&v){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(const std::string&v)
JKYi::LexicalCast::operator ()	config.h	/^   std::vector<T> operator()(const std::string&v){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(const std::string&v)
JKYi::LexicalCast::operator ()	log.cc	/^      LogDefine operator()(const std::string&str){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(const std::string&str)
JKYi::LexicalCast::operator ()	log.cc	/^     std::string operator()(const LogDefine&ld){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(const LogDefine&ld)
JKYi::LineFormatItem	log.cc	/^class LineFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
JKYi::LineFormatItem::LineFormatItem	log.cc	/^    LineFormatItem(const std::string& str = "") {}$/;"	f	class:JKYi::LineFormatItem	access:public	signature:(const std::string& str = ”)
JKYi::ListAllMember	config.cc	/^static void ListAllMember(const std::string&prefix,const YAML::Node&node,std::list<std::pair<std::string,const YAML::Node>>&output){$/;"	f	namespace:JKYi	signature:(const std::string&prefix,const YAML::Node&node,std::list<std::pair<std::string,const YAML::Node>>&output)
JKYi::LogAppender	log.h	/^class LogAppender{$/;"	c	namespace:JKYi
JKYi::LogAppender::MutexType	log.h	/^	typedef SpinLock MutexType;$/;"	t	class:JKYi::LogAppender	access:public
JKYi::LogAppender::getFormatter	log.cc	/^LogFormatter::ptr LogAppender::getFormatter(){$/;"	f	class:JKYi::LogAppender	signature:()
JKYi::LogAppender::getFormatter	log.h	/^    LogFormatter::ptr getFormatter(); $/;"	p	class:JKYi::LogAppender	access:public	signature:()
JKYi::LogAppender::getLevel	log.h	/^    LogLevel::Level getLevel(LogLevel::Level level){return m_level;}$/;"	f	class:JKYi::LogAppender	access:public	signature:(LogLevel::Level level)
JKYi::LogAppender::log	log.h	/^    virtual void log(std::shared_ptr<Logger> logger, LogLevel::Level level, LogEvent::ptr event) = 0;$/;"	p	class:JKYi::LogAppender	access:public	signature:(std::shared_ptr<Logger> logger, LogLevel::Level level, LogEvent::ptr event)
JKYi::LogAppender::m_formatter	log.h	/^    LogFormatter::ptr m_formatter;\/\/ÂÆö‰πâÊó•ÂøóËæìÂá∫ÁöÑÊ†ºÂºè$/;"	m	class:JKYi::LogAppender	access:protected
JKYi::LogAppender::m_hasFormatter	log.h	/^    bool m_hasFormatter=false;$/;"	m	class:JKYi::LogAppender	access:protected
JKYi::LogAppender::m_level	log.h	/^    LogLevel::Level m_level=LogLevel::DEBUG;\/\/ÈªòËÆ§‰∏∫debugÊ®°Âºè$/;"	m	class:JKYi::LogAppender	access:protected
JKYi::LogAppender::m_mutex	log.h	/^	MutexType m_mutex;$/;"	m	class:JKYi::LogAppender	access:protected
JKYi::LogAppender::ptr	log.h	/^    typedef std::shared_ptr<LogAppender> ptr;$/;"	t	class:JKYi::LogAppender	access:public
JKYi::LogAppender::setFormatter	log.cc	/^void LogAppender::setFormatter(LogFormatter::ptr formatter){$/;"	f	class:JKYi::LogAppender	signature:(LogFormatter::ptr formatter)
JKYi::LogAppender::setFormatter	log.h	/^    void setFormatter(LogFormatter::ptr formatter);$/;"	p	class:JKYi::LogAppender	access:public	signature:(LogFormatter::ptr formatter)
JKYi::LogAppender::setLevel	log.h	/^    void setLevel(LogLevel::Level level){m_level=level;}$/;"	f	class:JKYi::LogAppender	access:public	signature:(LogLevel::Level level)
JKYi::LogAppender::toYamlString	log.h	/^    virtual std::string toYamlString()=0;$/;"	p	class:JKYi::LogAppender	access:public	signature:()
JKYi::LogAppender::~LogAppender	log.h	/^    virtual ~LogAppender(){};\/\/Áî±‰∫éËØ•Á±ªÈúÄË¶Å‰Ωú‰∏∫Âü∫Á±ªÔºåÊâÄ‰ª•ËøôÈáåÁöÑËØùÂ∞±ÊûêÊûÑÂáΩÊï∞Áî≥Êòé‰∏∫ËôöÂáΩÊï∞ÔºåÈÅøÂÖçÂÜÖÂ≠òÊ≥ÑÊºè$/;"	f	class:JKYi::LogAppender	access:public	signature:()
JKYi::LogAppenderDefine	log.cc	/^struct LogAppenderDefine{$/;"	s	namespace:JKYi	file:
JKYi::LogAppenderDefine::file	log.cc	/^    std::string file;$/;"	m	struct:JKYi::LogAppenderDefine	file:	access:public
JKYi::LogAppenderDefine::formatter	log.cc	/^    std::string formatter;$/;"	m	struct:JKYi::LogAppenderDefine	file:	access:public
JKYi::LogAppenderDefine::level	log.cc	/^    LogLevel::Level level=LogLevel::UNKNOW;$/;"	m	struct:JKYi::LogAppenderDefine	file:	access:public
JKYi::LogAppenderDefine::operator ==	log.cc	/^    bool operator== (const LogAppenderDefine&rhv)const {$/;"	f	struct:JKYi::LogAppenderDefine	access:public	signature:(const LogAppenderDefine&rhv) const
JKYi::LogAppenderDefine::type	log.cc	/^    int type=0;\/\/2Ë°®Á§∫StdoutÔºå1Ë°®Á§∫file$/;"	m	struct:JKYi::LogAppenderDefine	file:	access:public
JKYi::LogDefine	log.cc	/^struct LogDefine{$/;"	s	namespace:JKYi	file:
JKYi::LogDefine::appenders	log.cc	/^   std::vector<LogAppenderDefine>appenders;$/;"	m	struct:JKYi::LogDefine	file:	access:public
JKYi::LogDefine::formatter	log.cc	/^   std::string formatter;$/;"	m	struct:JKYi::LogDefine	file:	access:public
JKYi::LogDefine::level	log.cc	/^   LogLevel::Level level=LogLevel::UNKNOW;$/;"	m	struct:JKYi::LogDefine	file:	access:public
JKYi::LogDefine::name	log.cc	/^   std::string name;$/;"	m	struct:JKYi::LogDefine	file:	access:public
JKYi::LogDefine::operator <	log.cc	/^   bool operator< (const LogDefine&rhv)const{$/;"	f	struct:JKYi::LogDefine	access:public	signature:(const LogDefine&rhv) const
JKYi::LogDefine::operator ==	log.cc	/^   bool operator== (const LogDefine&rhv)const {$/;"	f	struct:JKYi::LogDefine	access:public	signature:(const LogDefine&rhv) const
JKYi::LogEvent	log.h	/^class LogEvent{$/;"	c	namespace:JKYi
JKYi::LogEvent::LogEvent	log.cc	/^LogEvent::LogEvent(std::shared_ptr<Logger>logger$/;"	f	class:JKYi::LogEvent	signature:(std::shared_ptr<Logger>logger ,JKYi::LogLevel::Level level ,const char*file ,int32_t line ,uint32_t elapse ,uint32_t thread_id ,uint32_t fiber_id ,uint32_t time ,const std::string& threadName)
JKYi::LogEvent::LogEvent	log.h	/^   LogEvent(std::shared_ptr<Logger>logger$/;"	p	class:JKYi::LogEvent	access:public	signature:(std::shared_ptr<Logger>logger ,LogLevel::Level level ,const char*file ,int32_t line ,uint32_t elapse ,uint32_t thread_id ,uint32_t fiber_id ,uint32_t time ,const std::string&threadName)
JKYi::LogEvent::getContent	log.h	/^   std::string getContent() const{return m_ss.str();}$/;"	f	class:JKYi::LogEvent	access:public	signature:() const
JKYi::LogEvent::getElapse	log.h	/^   uint32_t getElapse()const {return m_elapse;}$/;"	f	class:JKYi::LogEvent	access:public	signature:() const
JKYi::LogEvent::getFiberId	log.h	/^   uint32_t getFiberId()const {return m_fiberId;}$/;"	f	class:JKYi::LogEvent	access:public	signature:() const
JKYi::LogEvent::getFile	log.h	/^   const char* getFile()const {return m_file;}$/;"	f	class:JKYi::LogEvent	access:public	signature:() const
JKYi::LogEvent::getLevel	log.h	/^   LogLevel::Level getLevel() const {return m_level;}$/;"	f	class:JKYi::LogEvent	access:public	signature:() const
JKYi::LogEvent::getLine	log.h	/^   int32_t getLine()const {return m_line;}$/;"	f	class:JKYi::LogEvent	access:public	signature:() const
JKYi::LogEvent::getLogger	log.h	/^   std::shared_ptr<Logger> getLogger()const {return m_logger;}$/;"	f	class:JKYi::LogEvent	access:public	signature:() const
JKYi::LogEvent::getSS	log.h	/^   std::stringstream& getSS() { return m_ss;}$/;"	f	class:JKYi::LogEvent	access:public	signature:()
JKYi::LogEvent::getThreadId	log.h	/^   uint32_t getThreadId()const {return m_threadId;}$/;"	f	class:JKYi::LogEvent	access:public	signature:() const
JKYi::LogEvent::getThreadName	log.h	/^   const std::string& getThreadName()const {return m_threadName;}$/;"	f	class:JKYi::LogEvent	access:public	signature:() const
JKYi::LogEvent::getTime	log.h	/^   uint32_t getTime()const{return m_time;}$/;"	f	class:JKYi::LogEvent	access:public	signature:() const
JKYi::LogEvent::m_elapse	log.h	/^   uint32_t m_elapse=0;\/\/Á®ãÂ∫èÂêØÂä®ÂºÄÂßãÂà∞Áé∞Âú®ÁöÑÊØ´ÁßíÊï∞$/;"	m	class:JKYi::LogEvent	access:private
JKYi::LogEvent::m_fiberId	log.h	/^   uint32_t m_fiberId=0;\/\/ÂçèÁ®ãID$/;"	m	class:JKYi::LogEvent	access:private
JKYi::LogEvent::m_file	log.h	/^   const char* m_file=nullptr;\/\/ÁõÆÊ†áÊó•ÂøóÊñá‰ª∂ÁöÑÂêçÁß∞$/;"	m	class:JKYi::LogEvent	access:private
JKYi::LogEvent::m_level	log.h	/^   LogLevel::Level m_level;$/;"	m	class:JKYi::LogEvent	access:private
JKYi::LogEvent::m_line	log.h	/^   int32_t m_line=0;\/\/Ë°åÂè∑$/;"	m	class:JKYi::LogEvent	access:private
JKYi::LogEvent::m_logger	log.h	/^   std::shared_ptr<Logger>m_logger;$/;"	m	class:JKYi::LogEvent	access:private
JKYi::LogEvent::m_ss	log.h	/^   std::stringstream m_ss;\/\/ÊµÅÔºåÁî®Êù•Â≠òÂÇ®Ë¶ÅËæìÂá∫ÁöÑÊó•Âøó$/;"	m	class:JKYi::LogEvent	access:private
JKYi::LogEvent::m_threadId	log.h	/^   uint32_t m_threadId=0;\/\/Á∫øÁ®ãID$/;"	m	class:JKYi::LogEvent	access:private
JKYi::LogEvent::m_threadName	log.h	/^   std::string m_threadName;$/;"	m	class:JKYi::LogEvent	access:private
JKYi::LogEvent::m_time	log.h	/^   uint32_t m_time=0;\/\/Êó∂Èó¥Êà≥$/;"	m	class:JKYi::LogEvent	access:private
JKYi::LogEvent::ptr	log.h	/^   typedef std::shared_ptr<LogEvent> ptr; $/;"	t	class:JKYi::LogEvent	access:public
JKYi::LogEventWrap	log.h	/^class LogEventWrap{$/;"	c	namespace:JKYi
JKYi::LogEventWrap::LogEventWrap	log.cc	/^LogEventWrap::LogEventWrap(LogEvent::ptr event)$/;"	f	class:JKYi::LogEventWrap	signature:(LogEvent::ptr event)
JKYi::LogEventWrap::LogEventWrap	log.h	/^   LogEventWrap(LogEvent::ptr event);$/;"	p	class:JKYi::LogEventWrap	access:public	signature:(LogEvent::ptr event)
JKYi::LogEventWrap::getEvent	log.h	/^   LogEvent::ptr getEvent()const {return m_event;}$/;"	f	class:JKYi::LogEventWrap	access:public	signature:() const
JKYi::LogEventWrap::getSS	log.cc	/^std::stringstream& LogEventWrap::getSS(){$/;"	f	class:JKYi::LogEventWrap	signature:()
JKYi::LogEventWrap::getSS	log.h	/^   std::stringstream& getSS();$/;"	p	class:JKYi::LogEventWrap	access:public	signature:()
JKYi::LogEventWrap::m_event	log.h	/^   LogEvent::ptr m_event;$/;"	m	class:JKYi::LogEventWrap	access:private
JKYi::LogEventWrap::~LogEventWrap	log.cc	/^LogEventWrap::~LogEventWrap(){$/;"	f	class:JKYi::LogEventWrap	signature:()
JKYi::LogEventWrap::~LogEventWrap	log.h	/^   ~LogEventWrap();$/;"	p	class:JKYi::LogEventWrap	access:public	signature:()
JKYi::LogFormatter	log.h	/^class LogFormatter{$/;"	c	namespace:JKYi
JKYi::LogFormatter::FormatItem	log.h	/^    class FormatItem{$/;"	c	class:JKYi::LogFormatter	access:public
JKYi::LogFormatter::FormatItem::format	log.h	/^       virtual void format(std::ostream&os,std::shared_ptr<Logger>logger,LogLevel::Level level,LogEvent::ptr event)=0;$/;"	p	class:JKYi::LogFormatter::FormatItem	access:public	signature:(std::ostream&os,std::shared_ptr<Logger>logger,LogLevel::Level level,LogEvent::ptr event)
JKYi::LogFormatter::FormatItem::ptr	log.h	/^       typedef std::shared_ptr<FormatItem> ptr;$/;"	t	class:JKYi::LogFormatter::FormatItem	access:public
JKYi::LogFormatter::FormatItem::~FormatItem	log.h	/^       virtual ~FormatItem(){}$/;"	f	class:JKYi::LogFormatter::FormatItem	access:public	signature:()
JKYi::LogFormatter::LogFormatter	log.cc	/^LogFormatter::LogFormatter(const std::string&pattern)$/;"	f	class:JKYi::LogFormatter	signature:(const std::string&pattern)
JKYi::LogFormatter::LogFormatter	log.h	/^    LogFormatter(const std::string&pattern);$/;"	p	class:JKYi::LogFormatter	access:public	signature:(const std::string&pattern)
JKYi::LogFormatter::format	log.cc	/^std::string LogFormatter::format(std::shared_ptr<Logger>logger,LogLevel::Level level,LogEvent::ptr event){$/;"	f	class:JKYi::LogFormatter	signature:(std::shared_ptr<Logger>logger,LogLevel::Level level,LogEvent::ptr event)
JKYi::LogFormatter::format	log.h	/^    std::string format(std::shared_ptr<Logger>logger,LogLevel::Level level,LogEvent::ptr event);$/;"	p	class:JKYi::LogFormatter	access:public	signature:(std::shared_ptr<Logger>logger,LogLevel::Level level,LogEvent::ptr event)
JKYi::LogFormatter::getPattern	log.h	/^    const std::string& getPattern()const{$/;"	f	class:JKYi::LogFormatter	access:public	signature:() const
JKYi::LogFormatter::init	log.cc	/^void LogFormatter::init(){$/;"	f	class:JKYi::LogFormatter	signature:()
JKYi::LogFormatter::init	log.h	/^    void init();$/;"	p	class:JKYi::LogFormatter	access:public	signature:()
JKYi::LogFormatter::isError	log.h	/^    bool isError()const{return m_error;}$/;"	f	class:JKYi::LogFormatter	access:public	signature:() const
JKYi::LogFormatter::m_error	log.h	/^    bool m_error=false;$/;"	m	class:JKYi::LogFormatter	access:private
JKYi::LogFormatter::m_items	log.h	/^    std::vector<FormatItem::ptr>m_items;$/;"	m	class:JKYi::LogFormatter	access:private
JKYi::LogFormatter::m_pattern	log.h	/^    std::string m_pattern;$/;"	m	class:JKYi::LogFormatter	access:private
JKYi::LogFormatter::ptr	log.h	/^    typedef std::shared_ptr<LogFormatter> ptr;$/;"	t	class:JKYi::LogFormatter	access:public
JKYi::LogIniter	log.cc	/^struct LogIniter{$/;"	s	namespace:JKYi	file:
JKYi::LogIniter::LogIniter	log.cc	/^    LogIniter(){$/;"	f	struct:JKYi::LogIniter	access:public	signature:()
JKYi::LogLevel	log.h	/^class LogLevel{$/;"	c	namespace:JKYi
JKYi::LogLevel::DEBUG	log.h	/^     DEBUG=1,$/;"	e	enum:JKYi::LogLevel::Level
JKYi::LogLevel::ERROR	log.h	/^     ERROR=4,$/;"	e	enum:JKYi::LogLevel::Level
JKYi::LogLevel::FATAL	log.h	/^     FATAL=5$/;"	e	enum:JKYi::LogLevel::Level
JKYi::LogLevel::FromString	log.cc	/^ LogLevel::Level LogLevel::FromString(const std::string&str){$/;"	f	class:JKYi::LogLevel	signature:(const std::string&str)
JKYi::LogLevel::FromString	log.h	/^   static LogLevel::Level FromString(const std::string&str);$/;"	p	class:JKYi::LogLevel	access:public	signature:(const std::string&str)
JKYi::LogLevel::INFO	log.h	/^     INFO=2,$/;"	e	enum:JKYi::LogLevel::Level
JKYi::LogLevel::Level	log.h	/^   enum Level{$/;"	g	class:JKYi::LogLevel	access:public
JKYi::LogLevel::ToString	log.cc	/^ const char* LogLevel::ToString(LogLevel::Level level){$/;"	f	class:JKYi::LogLevel	signature:(LogLevel::Level level)
JKYi::LogLevel::ToString	log.h	/^   static const char* ToString(LogLevel::Level level);$/;"	p	class:JKYi::LogLevel	access:public	signature:(LogLevel::Level level)
JKYi::LogLevel::UNKNOW	log.h	/^     UNKNOW=0,$/;"	e	enum:JKYi::LogLevel::Level
JKYi::LogLevel::WARN	log.h	/^     WARN=3,$/;"	e	enum:JKYi::LogLevel::Level
JKYi::Logger	log.h	/^class Logger:public std::enable_shared_from_this<Logger>{$/;"	c	namespace:JKYi	inherits:std::enable_shared_from_this
JKYi::Logger::Logger	log.cc	/^Logger::Logger(const std::string&name)$/;"	f	class:JKYi::Logger	signature:(const std::string&name)
JKYi::Logger::Logger	log.h	/^    Logger(const std::string& name="root");$/;"	p	class:JKYi::Logger	access:public	signature:(const std::string& name=”)
JKYi::Logger::MutexType	log.h	/^	typedef SpinLock MutexType;$/;"	t	class:JKYi::Logger	access:public
JKYi::Logger::addAppender	log.cc	/^void Logger::addAppender(LogAppender::ptr appender){$/;"	f	class:JKYi::Logger	signature:(LogAppender::ptr appender)
JKYi::Logger::addAppender	log.h	/^    void addAppender(LogAppender::ptr appender);$/;"	p	class:JKYi::Logger	access:public	signature:(LogAppender::ptr appender)
JKYi::Logger::clearAppender	log.cc	/^void Logger::clearAppender(){$/;"	f	class:JKYi::Logger	signature:()
JKYi::Logger::clearAppender	log.h	/^    void clearAppender();$/;"	p	class:JKYi::Logger	access:public	signature:()
JKYi::Logger::debug	log.cc	/^void Logger::debug(LogEvent::ptr event){$/;"	f	class:JKYi::Logger	signature:(LogEvent::ptr event)
JKYi::Logger::debug	log.h	/^    void debug(LogEvent::ptr event);\/\/ËæìÂá∫debugÁ∫ßÂà´ÁöÑÊó•Âøó$/;"	p	class:JKYi::Logger	access:public	signature:(LogEvent::ptr event)
JKYi::Logger::delAppender	log.cc	/^void Logger::delAppender(LogAppender::ptr appender){$/;"	f	class:JKYi::Logger	signature:(LogAppender::ptr appender)
JKYi::Logger::delAppender	log.h	/^    void delAppender(LogAppender::ptr appender);$/;"	p	class:JKYi::Logger	access:public	signature:(LogAppender::ptr appender)
JKYi::Logger::error	log.cc	/^void Logger::error(LogEvent::ptr event){$/;"	f	class:JKYi::Logger	signature:(LogEvent::ptr event)
JKYi::Logger::error	log.h	/^    void error(LogEvent::ptr event);$/;"	p	class:JKYi::Logger	access:public	signature:(LogEvent::ptr event)
JKYi::Logger::fatal	log.cc	/^void Logger::fatal(LogEvent::ptr event){$/;"	f	class:JKYi::Logger	signature:(LogEvent::ptr event)
JKYi::Logger::fatal	log.h	/^    void fatal(LogEvent::ptr event);$/;"	p	class:JKYi::Logger	access:public	signature:(LogEvent::ptr event)
JKYi::Logger::getFormatter	log.cc	/^LogFormatter::ptr Logger::getFormatter(){$/;"	f	class:JKYi::Logger	signature:()
JKYi::Logger::getFormatter	log.h	/^    LogFormatter::ptr getFormatter();$/;"	p	class:JKYi::Logger	access:public	signature:()
JKYi::Logger::getLevel	log.h	/^    LogLevel::Level getLevel()const {return m_level;}$/;"	f	class:JKYi::Logger	access:public	signature:() const
JKYi::Logger::getName	log.h	/^    std::string getName()const {return m_name;}$/;"	f	class:JKYi::Logger	access:public	signature:() const
JKYi::Logger::info	log.cc	/^void Logger::info(LogEvent::ptr event){$/;"	f	class:JKYi::Logger	signature:(LogEvent::ptr event)
JKYi::Logger::info	log.h	/^    void info(LogEvent::ptr event);$/;"	p	class:JKYi::Logger	access:public	signature:(LogEvent::ptr event)
JKYi::Logger::log	log.cc	/^void Logger::log(LogLevel::Level level,LogEvent::ptr event){$/;"	f	class:JKYi::Logger	signature:(LogLevel::Level level,LogEvent::ptr event)
JKYi::Logger::log	log.h	/^    void log(LogLevel::Level level,LogEvent::ptr event);$/;"	p	class:JKYi::Logger	access:public	signature:(LogLevel::Level level,LogEvent::ptr event)
JKYi::Logger::m_appenders	log.h	/^    std::list<LogAppender::ptr>m_appenders;\/\/AppenderÈõÜÂêà$/;"	m	class:JKYi::Logger	access:private
JKYi::Logger::m_formatter	log.h	/^    LogFormatter::ptr m_formatter;\/\/Êó•ÂøóÁöÑËæìÂá∫Ê†ºÂºè$/;"	m	class:JKYi::Logger	access:private
JKYi::Logger::m_level	log.h	/^    LogLevel::Level m_level;  \/\/Êó•ÂøóÁöÑÁ∫ßÂà´ÔºåÂè™ÊúâÊª°Ë∂≥Á∫ßÂà´ÁöÑÊó•ÂøóÊâç‰ºöË¢´ËæìÂá∫workSpace\/JKYi\/log.h$/;"	m	class:JKYi::Logger	access:private
JKYi::Logger::m_mutex	log.h	/^	MutexType m_mutex;$/;"	m	class:JKYi::Logger	access:private
JKYi::Logger::m_name	log.h	/^    std::string m_name;       \/\/Êó•ÂøóÁöÑÂêçÁß∞$/;"	m	class:JKYi::Logger	access:private
JKYi::Logger::m_root	log.h	/^    Logger::ptr m_root;$/;"	m	class:JKYi::Logger	access:private
JKYi::Logger::ptr	log.h	/^    typedef std::shared_ptr<Logger> ptr;$/;"	t	class:JKYi::Logger	access:public
JKYi::Logger::setFormatter	log.cc	/^void Logger::setFormatter(LogFormatter::ptr formatter){$/;"	f	class:JKYi::Logger	signature:(LogFormatter::ptr formatter)
JKYi::Logger::setFormatter	log.cc	/^void Logger::setFormatter(const std::string&str){$/;"	f	class:JKYi::Logger	signature:(const std::string&str)
JKYi::Logger::setFormatter	log.h	/^    void setFormatter(LogFormatter::ptr formatter);$/;"	p	class:JKYi::Logger	access:public	signature:(LogFormatter::ptr formatter)
JKYi::Logger::setFormatter	log.h	/^    void setFormatter(const std::string &str);$/;"	p	class:JKYi::Logger	access:public	signature:(const std::string &str)
JKYi::Logger::setLevel	log.h	/^    void setLevel(LogLevel::Level level){m_level=level;}$/;"	f	class:JKYi::Logger	access:public	signature:(LogLevel::Level level)
JKYi::Logger::toYamlString	log.cc	/^std::string Logger::toYamlString(){$/;"	f	class:JKYi::Logger	signature:()
JKYi::Logger::toYamlString	log.h	/^    std::string toYamlString();$/;"	p	class:JKYi::Logger	access:public	signature:()
JKYi::Logger::warn	log.cc	/^void Logger::warn(LogEvent::ptr event){$/;"	f	class:JKYi::Logger	signature:(LogEvent::ptr event)
JKYi::Logger::warn	log.h	/^    void warn(LogEvent::ptr event);$/;"	p	class:JKYi::Logger	access:public	signature:(LogEvent::ptr event)
JKYi::LoggerManager	log.h	/^class LoggerManager{$/;"	c	namespace:JKYi
JKYi::LoggerManager::LoggerManager	log.cc	/^LoggerManager::LoggerManager(){$/;"	f	class:JKYi::LoggerManager	signature:()
JKYi::LoggerManager::LoggerManager	log.h	/^     LoggerManager();$/;"	p	class:JKYi::LoggerManager	access:public	signature:()
JKYi::LoggerManager::MutexType	log.h	/^     typedef SpinLock MutexType;$/;"	t	class:JKYi::LoggerManager	access:public
JKYi::LoggerManager::getLogger	log.cc	/^Logger::ptr LoggerManager::getLogger(const std::string&name){$/;"	f	class:JKYi::LoggerManager	signature:(const std::string&name)
JKYi::LoggerManager::getLogger	log.h	/^     Logger::ptr getLogger(const std::string&name);$/;"	p	class:JKYi::LoggerManager	access:public	signature:(const std::string&name)
JKYi::LoggerManager::getRoot	log.h	/^     Logger::ptr getRoot()const {return m_root;}$/;"	f	class:JKYi::LoggerManager	access:public	signature:() const
JKYi::LoggerManager::init	log.cc	/^void LoggerManager::init(){$/;"	f	class:JKYi::LoggerManager	signature:()
JKYi::LoggerManager::init	log.h	/^     void init();$/;"	p	class:JKYi::LoggerManager	access:public	signature:()
JKYi::LoggerManager::m_loggers	log.h	/^    std::map<std::string,Logger::ptr>m_loggers;$/;"	m	class:JKYi::LoggerManager	access:private
JKYi::LoggerManager::m_mutex	log.h	/^	MutexType m_mutex;$/;"	m	class:JKYi::LoggerManager	access:private
JKYi::LoggerManager::m_root	log.h	/^    Logger::ptr m_root;$/;"	m	class:JKYi::LoggerManager	access:private
JKYi::LoggerManager::toYamlString	log.cc	/^std::string LoggerManager::toYamlString(){$/;"	f	class:JKYi::LoggerManager	signature:()
JKYi::LoggerManager::toYamlString	log.h	/^     std::string toYamlString();$/;"	p	class:JKYi::LoggerManager	access:public	signature:()
JKYi::LoggerMgr	log.h	/^typedef JKYi::Singleton<LoggerManager> LoggerMgr;$/;"	t	namespace:JKYi
JKYi::MallocStackAllocator	fiber.cc	/^class MallocStackAllocator{$/;"	c	namespace:JKYi	file:
JKYi::MallocStackAllocator::Alloc	fiber.cc	/^   static void* Alloc(size_t size){$/;"	f	class:JKYi::MallocStackAllocator	access:public	signature:(size_t size)
JKYi::MallocStackAllocator::Dealloc	fiber.cc	/^   static void Dealloc(void *ptr,size_t size){$/;"	f	class:JKYi::MallocStackAllocator	access:public	signature:(void *ptr,size_t size)
JKYi::MessageFormatItem	log.cc	/^class MessageFormatItem:public LogFormatter::FormatItem{$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
JKYi::MessageFormatItem::MessageFormatItem	log.cc	/^   MessageFormatItem(const std::string& str=""){}$/;"	f	class:JKYi::MessageFormatItem	access:public	signature:(const std::string& str=”)
JKYi::Mutex	mutex.h	/^class Mutex: Noncopyable{$/;"	c	namespace:JKYi	inherits:Noncopyable
JKYi::Mutex::Lock	mutex.h	/^    typedef ScopedLockImpl<Mutex>  Lock;$/;"	t	class:JKYi::Mutex	access:public
JKYi::Mutex::Mutex	mutex.h	/^   Mutex(){$/;"	f	class:JKYi::Mutex	access:public	signature:()
JKYi::Mutex::lock	mutex.h	/^   void lock(){$/;"	f	class:JKYi::Mutex	access:public	signature:()
JKYi::Mutex::m_mutex	mutex.h	/^   pthread_mutex_t m_mutex;$/;"	m	class:JKYi::Mutex	access:private
JKYi::Mutex::unlock	mutex.h	/^   void unlock(){$/;"	f	class:JKYi::Mutex	access:public	signature:()
JKYi::Mutex::~Mutex	mutex.h	/^   ~Mutex(){$/;"	f	class:JKYi::Mutex	access:public	signature:()
JKYi::NameFormatItem	log.cc	/^class NameFormatItem:public LogFormatter::FormatItem{$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
JKYi::NameFormatItem::NameFormatItem	log.cc	/^    NameFormatItem(const std::string&str=""){}$/;"	f	class:JKYi::NameFormatItem	access:public	signature:(const std::string&str=”)
JKYi::NewLineFormatItem	log.cc	/^class NewLineFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
JKYi::NewLineFormatItem::NewLineFormatItem	log.cc	/^    NewLineFormatItem(const std::string& str = "") {}$/;"	f	class:JKYi::NewLineFormatItem	access:public	signature:(const std::string& str = ”)
JKYi::Noncopyable	noncopyable.h	/^class Noncopyable{$/;"	c	namespace:JKYi
JKYi::Noncopyable::Noncopyable	noncopyable.h	/^  Noncopyable()=default; $/;"	p	class:JKYi::Noncopyable	access:public	signature:()
JKYi::Noncopyable::Noncopyable	noncopyable.h	/^  Noncopyable(Noncopyable&&)=delete;$/;"	p	class:JKYi::Noncopyable	access:public	signature:(Noncopyable&&)
JKYi::Noncopyable::Noncopyable	noncopyable.h	/^  Noncopyable(const Noncopyable&)=delete;$/;"	p	class:JKYi::Noncopyable	access:public	signature:(const Noncopyable&)
JKYi::Noncopyable::operator =	noncopyable.h	/^  Noncopyable& operator= (const Noncopyable&)=delete;$/;"	p	class:JKYi::Noncopyable	access:public	signature:(const Noncopyable&)
JKYi::Noncopyable::operator =	noncopyable.h	/^  Noncopyable&& operator= (Noncopyable&&)=delete;$/;"	p	class:JKYi::Noncopyable	access:public	signature:(Noncopyable&&)
JKYi::Noncopyable::~Noncopyable	noncopyable.h	/^  ~Noncopyable()=default;$/;"	p	class:JKYi::Noncopyable	access:public	signature:()
JKYi::OnTimer	timer.cc	/^static void OnTimer(std::weak_ptr<void>weak_cond,std::function<void()>cb){$/;"	f	namespace:JKYi	signature:(std::weak_ptr<void>weak_cond,std::function<void()>cb)
JKYi::RWMutex	mutex.h	/^class RWMutex:Noncopyable{$/;"	c	namespace:JKYi	inherits:Noncopyable
JKYi::RWMutex::RWMutex	mutex.h	/^    RWMutex(){$/;"	f	class:JKYi::RWMutex	access:public	signature:()
JKYi::RWMutex::ReadLock	mutex.h	/^    typedef ReadScopedLockImpl<RWMutex> ReadLock;$/;"	t	class:JKYi::RWMutex	access:public
JKYi::RWMutex::WriteLock	mutex.h	/^	typedef WriteScopedLockImpl<RWMutex> WriteLock;$/;"	t	class:JKYi::RWMutex	access:public
JKYi::RWMutex::m_lock	mutex.h	/^   pthread_rwlock_t m_lock;$/;"	m	class:JKYi::RWMutex	access:private
JKYi::RWMutex::rdlock	mutex.h	/^	void rdlock(){$/;"	f	class:JKYi::RWMutex	access:public	signature:()
JKYi::RWMutex::unlock	mutex.h	/^	void unlock(){$/;"	f	class:JKYi::RWMutex	access:public	signature:()
JKYi::RWMutex::wrlock	mutex.h	/^	void wrlock(){$/;"	f	class:JKYi::RWMutex	access:public	signature:()
JKYi::RWMutex::~RWMutex	mutex.h	/^	~RWMutex(){$/;"	f	class:JKYi::RWMutex	access:public	signature:()
JKYi::ReadScopedLockImpl	mutex.h	/^class ReadScopedLockImpl{$/;"	c	namespace:JKYi
JKYi::ReadScopedLockImpl::ReadScopedLockImpl	mutex.h	/^  ReadScopedLockImpl(T&mutex)$/;"	f	class:JKYi::ReadScopedLockImpl	access:public	signature:(T&mutex)
JKYi::ReadScopedLockImpl::lock	mutex.h	/^  void lock(){$/;"	f	class:JKYi::ReadScopedLockImpl	access:public	signature:()
JKYi::ReadScopedLockImpl::m_locked	mutex.h	/^  bool m_locked;$/;"	m	class:JKYi::ReadScopedLockImpl	access:private
JKYi::ReadScopedLockImpl::m_mutex	mutex.h	/^  T& m_mutex;$/;"	m	class:JKYi::ReadScopedLockImpl	access:private
JKYi::ReadScopedLockImpl::unlock	mutex.h	/^  void unlock(){$/;"	f	class:JKYi::ReadScopedLockImpl	access:public	signature:()
JKYi::ReadScopedLockImpl::~ReadScopedLockImpl	mutex.h	/^  ~ReadScopedLockImpl(){$/;"	f	class:JKYi::ReadScopedLockImpl	access:public	signature:()
JKYi::Scheduler	scheduler.h	/^class Scheduler{$/;"	c	namespace:JKYi
JKYi::Scheduler::FiberAndThread	scheduler.h	/^  struct FiberAndThread{$/;"	s	class:JKYi::Scheduler	access:private
JKYi::Scheduler::FiberAndThread::FiberAndThread	scheduler.h	/^	 FiberAndThread()$/;"	f	struct:JKYi::Scheduler::FiberAndThread	access:public	signature:()
JKYi::Scheduler::FiberAndThread::FiberAndThread	scheduler.h	/^	 FiberAndThread(Fiber::ptr * f,int thr)$/;"	f	struct:JKYi::Scheduler::FiberAndThread	access:public	signature:(Fiber::ptr * f,int thr)
JKYi::Scheduler::FiberAndThread::FiberAndThread	scheduler.h	/^	 FiberAndThread(Fiber::ptr f,int thr)$/;"	f	struct:JKYi::Scheduler::FiberAndThread	access:public	signature:(Fiber::ptr f,int thr)
JKYi::Scheduler::FiberAndThread::FiberAndThread	scheduler.h	/^	 FiberAndThread(std::function<void ()>*f,int thr)$/;"	f	struct:JKYi::Scheduler::FiberAndThread	access:public	signature:(std::function<void ()>*f,int thr)
JKYi::Scheduler::FiberAndThread::FiberAndThread	scheduler.h	/^	 FiberAndThread(std::function<void ()>f,int thr)$/;"	f	struct:JKYi::Scheduler::FiberAndThread	access:public	signature:(std::function<void ()>f,int thr)
JKYi::Scheduler::FiberAndThread::cb	scheduler.h	/^	 std::function<void ()> cb;$/;"	m	struct:JKYi::Scheduler::FiberAndThread	access:public
JKYi::Scheduler::FiberAndThread::fiber	scheduler.h	/^     Fiber::ptr fiber; $/;"	m	struct:JKYi::Scheduler::FiberAndThread	access:public
JKYi::Scheduler::FiberAndThread::reset	scheduler.h	/^	 void reset(){$/;"	f	struct:JKYi::Scheduler::FiberAndThread	access:public	signature:()
JKYi::Scheduler::FiberAndThread::thread	scheduler.h	/^	 int thread;$/;"	m	struct:JKYi::Scheduler::FiberAndThread	access:public
JKYi::Scheduler::GetMainFiber	scheduler.cc	/^Fiber* Scheduler::GetMainFiber(){$/;"	f	class:JKYi::Scheduler	signature:()
JKYi::Scheduler::GetMainFiber	scheduler.h	/^   static Fiber* GetMainFiber();$/;"	p	class:JKYi::Scheduler	access:public	signature:()
JKYi::Scheduler::GetThis	scheduler.cc	/^Scheduler* Scheduler::GetThis(){$/;"	f	class:JKYi::Scheduler	signature:()
JKYi::Scheduler::GetThis	scheduler.h	/^   static Scheduler* GetThis();$/;"	p	class:JKYi::Scheduler	access:public	signature:()
JKYi::Scheduler::MutexType	scheduler.h	/^   typedef Mutex MutexType;$/;"	t	class:JKYi::Scheduler	access:public
JKYi::Scheduler::Scheduler	scheduler.cc	/^Scheduler::Scheduler(size_t threads,bool use_caller,const std::string&name)$/;"	f	class:JKYi::Scheduler	signature:(size_t threads,bool use_caller,const std::string&name)
JKYi::Scheduler::Scheduler	scheduler.h	/^   Scheduler(size_t threads=1,bool use_caller=true,const std::string&name="");$/;"	p	class:JKYi::Scheduler	access:public	signature:(size_t threads=1,bool use_caller=true,const std::string&name=”)
JKYi::Scheduler::getName	scheduler.h	/^   const std::string& getName()const {return m_name;}$/;"	f	class:JKYi::Scheduler	access:public	signature:() const
JKYi::Scheduler::hasIdleThreads	scheduler.h	/^   bool hasIdleThreads(){return m_idleThreadCount>0;}$/;"	f	class:JKYi::Scheduler	access:protected	signature:()
JKYi::Scheduler::idle	scheduler.cc	/^void Scheduler::idle(){$/;"	f	class:JKYi::Scheduler	signature:()
JKYi::Scheduler::idle	scheduler.h	/^   virtual void idle();$/;"	p	class:JKYi::Scheduler	access:protected	signature:()
JKYi::Scheduler::m_activeThreadCount	scheduler.h	/^   std::atomic<size_t> m_activeThreadCount={0};$/;"	m	class:JKYi::Scheduler	access:protected
JKYi::Scheduler::m_autoStop	scheduler.h	/^   bool m_autoStop=false;$/;"	m	class:JKYi::Scheduler	access:protected
JKYi::Scheduler::m_fibers	scheduler.h	/^  std::list<FiberAndThread> m_fibers;$/;"	m	class:JKYi::Scheduler	access:private
JKYi::Scheduler::m_idleThreadCount	scheduler.h	/^   std::atomic<size_t> m_idleThreadCount={0};$/;"	m	class:JKYi::Scheduler	access:protected
JKYi::Scheduler::m_mutex	scheduler.h	/^   MutexType m_mutex;$/;"	m	class:JKYi::Scheduler	access:private
JKYi::Scheduler::m_name	scheduler.h	/^  std::string m_name;$/;"	m	class:JKYi::Scheduler	access:private
JKYi::Scheduler::m_rootFiber	scheduler.h	/^  Fiber::ptr m_rootFiber;$/;"	m	class:JKYi::Scheduler	access:private
JKYi::Scheduler::m_rootThread	scheduler.h	/^   int m_rootThread=0;$/;"	m	class:JKYi::Scheduler	access:protected
JKYi::Scheduler::m_stopping	scheduler.h	/^   bool m_stopping=true;$/;"	m	class:JKYi::Scheduler	access:protected
JKYi::Scheduler::m_threadCount	scheduler.h	/^   size_t m_threadCount=0;$/;"	m	class:JKYi::Scheduler	access:protected
JKYi::Scheduler::m_threadIds	scheduler.h	/^   std::vector<int> m_threadIds;$/;"	m	class:JKYi::Scheduler	access:protected
JKYi::Scheduler::m_threads	scheduler.h	/^  std::vector<Thread::ptr> m_threads;$/;"	m	class:JKYi::Scheduler	access:private
JKYi::Scheduler::ptr	scheduler.h	/^   typedef std::shared_ptr<Scheduler> ptr;$/;"	t	class:JKYi::Scheduler	access:public
JKYi::Scheduler::run	scheduler.cc	/^void Scheduler::run(){$/;"	f	class:JKYi::Scheduler	signature:()
JKYi::Scheduler::run	scheduler.h	/^   void run();$/;"	p	class:JKYi::Scheduler	access:protected	signature:()
JKYi::Scheduler::schedule	scheduler.h	/^   void schedule(FiberOrCb fc,int thread=-1){$/;"	f	class:JKYi::Scheduler	access:public	signature:(FiberOrCb fc,int thread=-1)
JKYi::Scheduler::schedule	scheduler.h	/^   void schedule(InputIterator begin,InputIterator end){$/;"	f	class:JKYi::Scheduler	access:public	signature:(InputIterator begin,InputIterator end)
JKYi::Scheduler::scheduleNoLock	scheduler.h	/^   bool scheduleNoLock(FiberOrCb fc,int thread){$/;"	f	class:JKYi::Scheduler	access:private	signature:(FiberOrCb fc,int thread)
JKYi::Scheduler::setThis	scheduler.cc	/^void Scheduler::setThis(){$/;"	f	class:JKYi::Scheduler	signature:()
JKYi::Scheduler::setThis	scheduler.h	/^   void setThis();$/;"	p	class:JKYi::Scheduler	access:protected	signature:()
JKYi::Scheduler::start	scheduler.cc	/^void Scheduler::start(){$/;"	f	class:JKYi::Scheduler	signature:()
JKYi::Scheduler::start	scheduler.h	/^   void start();$/;"	p	class:JKYi::Scheduler	access:public	signature:()
JKYi::Scheduler::stop	scheduler.cc	/^void Scheduler::stop(){$/;"	f	class:JKYi::Scheduler	signature:()
JKYi::Scheduler::stop	scheduler.h	/^   void stop();$/;"	p	class:JKYi::Scheduler	access:public	signature:()
JKYi::Scheduler::stopping	scheduler.cc	/^bool Scheduler::stopping(){$/;"	f	class:JKYi::Scheduler	signature:()
JKYi::Scheduler::stopping	scheduler.h	/^   virtual bool stopping();$/;"	p	class:JKYi::Scheduler	access:protected	signature:()
JKYi::Scheduler::tickle	scheduler.cc	/^void Scheduler::tickle(){$/;"	f	class:JKYi::Scheduler	signature:()
JKYi::Scheduler::tickle	scheduler.h	/^   virtual void tickle();$/;"	p	class:JKYi::Scheduler	access:protected	signature:()
JKYi::Scheduler::~Scheduler	scheduler.cc	/^Scheduler::~Scheduler(){$/;"	f	class:JKYi::Scheduler	signature:()
JKYi::Scheduler::~Scheduler	scheduler.h	/^   virtual ~Scheduler();$/;"	p	class:JKYi::Scheduler	access:public	signature:()
JKYi::ScopedLockImpl	mutex.h	/^class ScopedLockImpl{$/;"	c	namespace:JKYi
JKYi::ScopedLockImpl::ScopedLockImpl	mutex.h	/^  ScopedLockImpl(T&mutex)$/;"	f	class:JKYi::ScopedLockImpl	access:public	signature:(T&mutex)
JKYi::ScopedLockImpl::lock	mutex.h	/^  void lock(){$/;"	f	class:JKYi::ScopedLockImpl	access:public	signature:()
JKYi::ScopedLockImpl::m_locked	mutex.h	/^  bool m_locked;$/;"	m	class:JKYi::ScopedLockImpl	access:private
JKYi::ScopedLockImpl::m_mutex	mutex.h	/^  T& m_mutex;$/;"	m	class:JKYi::ScopedLockImpl	access:private
JKYi::ScopedLockImpl::unlock	mutex.h	/^  void unlock(){$/;"	f	class:JKYi::ScopedLockImpl	access:public	signature:()
JKYi::ScopedLockImpl::~ScopedLockImpl	mutex.h	/^  ~ScopedLockImpl(){$/;"	f	class:JKYi::ScopedLockImpl	access:public	signature:()
JKYi::Semaphore	mutex.h	/^class Semaphore:Noncopyable{$/;"	c	namespace:JKYi	inherits:Noncopyable
JKYi::Semaphore::Semaphore	mutex.cc	/^Semaphore::Semaphore(uint32_t count){$/;"	f	class:JKYi::Semaphore	signature:(uint32_t count)
JKYi::Semaphore::Semaphore	mutex.h	/^   Semaphore(uint32_t count=0);$/;"	p	class:JKYi::Semaphore	access:public	signature:(uint32_t count=0)
JKYi::Semaphore::m_semaphore	mutex.h	/^   sem_t m_semaphore; $/;"	m	class:JKYi::Semaphore	access:private
JKYi::Semaphore::notify	mutex.cc	/^void Semaphore::notify(){$/;"	f	class:JKYi::Semaphore	signature:()
JKYi::Semaphore::notify	mutex.h	/^   void notify();$/;"	p	class:JKYi::Semaphore	access:public	signature:()
JKYi::Semaphore::wait	mutex.cc	/^void Semaphore::wait(){$/;"	f	class:JKYi::Semaphore	signature:()
JKYi::Semaphore::wait	mutex.h	/^   void wait();$/;"	p	class:JKYi::Semaphore	access:public	signature:()
JKYi::Semaphore::~Semaphore	mutex.cc	/^Semaphore::~Semaphore(){$/;"	f	class:JKYi::Semaphore	signature:()
JKYi::Semaphore::~Semaphore	mutex.h	/^   ~Semaphore();$/;"	p	class:JKYi::Semaphore	access:public	signature:()
JKYi::Singleton	singleton.h	/^class Singleton{$/;"	c	namespace:JKYi
JKYi::Singleton::GetInstance	singleton.h	/^   static T* GetInstance(){$/;"	f	class:JKYi::Singleton	access:public	signature:()
JKYi::SingletonPtr	singleton.h	/^class SingletonPtr{$/;"	c	namespace:JKYi
JKYi::SingletonPtr::getInstance	singleton.h	/^    static std::shared_ptr<T> getInstance(){$/;"	f	class:JKYi::SingletonPtr	access:public	signature:()
JKYi::SpinLock	mutex.h	/^class SpinLock:Noncopyable{$/;"	c	namespace:JKYi	inherits:Noncopyable
JKYi::SpinLock::Lock	mutex.h	/^   typedef ScopedLockImpl<SpinLock>   Lock;$/;"	t	class:JKYi::SpinLock	access:public
JKYi::SpinLock::SpinLock	mutex.h	/^   SpinLock(){$/;"	f	class:JKYi::SpinLock	access:public	signature:()
JKYi::SpinLock::lock	mutex.h	/^   void lock(){$/;"	f	class:JKYi::SpinLock	access:public	signature:()
JKYi::SpinLock::m_mutex	mutex.h	/^   pthread_spinlock_t m_mutex;$/;"	m	class:JKYi::SpinLock	access:private
JKYi::SpinLock::unlock	mutex.h	/^   void unlock(){$/;"	f	class:JKYi::SpinLock	access:public	signature:()
JKYi::SpinLock::~SpinLock	mutex.h	/^   ~SpinLock(){$/;"	f	class:JKYi::SpinLock	access:public	signature:()
JKYi::StdoutLogAppender	log.h	/^class StdoutLogAppender:public LogAppender{$/;"	c	namespace:JKYi	inherits:LogAppender
JKYi::StdoutLogAppender::log	log.cc	/^void StdoutLogAppender::log(std::shared_ptr<Logger>logger,LogLevel::Level level,LogEvent::ptr event){$/;"	f	class:JKYi::StdoutLogAppender	signature:(std::shared_ptr<Logger>logger,LogLevel::Level level,LogEvent::ptr event)
JKYi::StdoutLogAppender::override	log.h	/^    std::string toYamlString()override;$/;"	m	class:JKYi::StdoutLogAppender	access:public
JKYi::StdoutLogAppender::override	log.h	/^    void log(Logger::ptr logger, LogLevel::Level level, LogEvent::ptr event) override;$/;"	m	class:JKYi::StdoutLogAppender	access:public
JKYi::StdoutLogAppender::ptr	log.h	/^    typedef std::shared_ptr<StdoutLogAppender> ptr;$/;"	t	class:JKYi::StdoutLogAppender	access:public
JKYi::StdoutLogAppender::toYamlString	log.cc	/^std::string StdoutLogAppender::toYamlString(){$/;"	f	class:JKYi::StdoutLogAppender	signature:()
JKYi::StringFormatItem	log.cc	/^class StringFormatItem:public LogFormatter::FormatItem{$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
JKYi::StringFormatItem::StringFormatItem	log.cc	/^   StringFormatItem(const std::string&str)$/;"	f	class:JKYi::StringFormatItem	access:public	signature:(const std::string&str)
JKYi::StringFormatItem::m_string	log.cc	/^   std::string m_string;$/;"	m	class:JKYi::StringFormatItem	file:	access:private
JKYi::TabFormatItem	log.cc	/^class TabFormatItem:public LogFormatter::FormatItem{$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
JKYi::TabFormatItem::TabFormatItem	log.cc	/^   TabFormatItem(const std::string str=""){}$/;"	f	class:JKYi::TabFormatItem	access:public	signature:(const std::string str=”)
JKYi::TabFormatItem::m_string	log.cc	/^   std::string m_string;$/;"	m	class:JKYi::TabFormatItem	file:	access:private
JKYi::Thread	thread.h	/^class Thread:Noncopyable {$/;"	c	namespace:JKYi	inherits:Noncopyable
JKYi::Thread::GetName	thread.cc	/^const std::string& Thread::GetName(){$/;"	f	class:JKYi::Thread	signature:()
JKYi::Thread::GetName	thread.h	/^   static const std::string& GetName();$/;"	p	class:JKYi::Thread	access:public	signature:()
JKYi::Thread::GetThis	thread.cc	/^Thread* Thread::GetThis(){$/;"	f	class:JKYi::Thread	signature:()
JKYi::Thread::GetThis	thread.h	/^   static Thread* GetThis();$/;"	p	class:JKYi::Thread	access:public	signature:()
JKYi::Thread::Thread	thread.cc	/^Thread::Thread(std::function<void()> cb,const std::string &name)$/;"	f	class:JKYi::Thread	signature:(std::function<void()> cb,const std::string &name)
JKYi::Thread::Thread	thread.h	/^   Thread(std::function<void()> cb,const std::string &name); $/;"	p	class:JKYi::Thread	access:public	signature:(std::function<void()> cb,const std::string &name)
JKYi::Thread::getId	thread.h	/^   pid_t getId()const{return m_id;}$/;"	f	class:JKYi::Thread	access:public	signature:() const
JKYi::Thread::getName	thread.h	/^   const std::string& getName()const{return m_name;} $/;"	f	class:JKYi::Thread	access:public	signature:() const
JKYi::Thread::join	thread.cc	/^void Thread::join(){$/;"	f	class:JKYi::Thread	signature:()
JKYi::Thread::join	thread.h	/^   void join();$/;"	p	class:JKYi::Thread	access:public	signature:()
JKYi::Thread::m_cb	thread.h	/^   std::function<void()>m_cb;$/;"	m	class:JKYi::Thread	access:private
JKYi::Thread::m_id	thread.h	/^   pid_t m_id=-1;$/;"	m	class:JKYi::Thread	access:private
JKYi::Thread::m_name	thread.h	/^   std::string m_name;$/;"	m	class:JKYi::Thread	access:private
JKYi::Thread::m_semaphore	thread.h	/^   Semaphore m_semaphore;$/;"	m	class:JKYi::Thread	access:private
JKYi::Thread::m_thread	thread.h	/^   pthread_t m_thread=0;$/;"	m	class:JKYi::Thread	access:private
JKYi::Thread::ptr	thread.h	/^   typedef std::shared_ptr<Thread> ptr;$/;"	t	class:JKYi::Thread	access:public
JKYi::Thread::run	thread.cc	/^ void * Thread::run(void*arg){$/;"	f	class:JKYi::Thread	signature:(void*arg)
JKYi::Thread::run	thread.h	/^   static void * run(void*arg);$/;"	p	class:JKYi::Thread	access:private	signature:(void*arg)
JKYi::Thread::setName	thread.cc	/^void Thread::setName(const std::string&name){$/;"	f	class:JKYi::Thread	signature:(const std::string&name)
JKYi::Thread::setName	thread.h	/^   static void setName(const std::string&name);$/;"	p	class:JKYi::Thread	access:public	signature:(const std::string&name)
JKYi::Thread::~Thread	thread.cc	/^Thread::~Thread(){$/;"	f	class:JKYi::Thread	signature:()
JKYi::Thread::~Thread	thread.h	/^   ~Thread(); $/;"	p	class:JKYi::Thread	access:public	signature:()
JKYi::ThreadIdFormatItem	log.cc	/^class ThreadIdFormatItem:public LogFormatter::FormatItem{$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
JKYi::ThreadIdFormatItem::ThreadIdFormatItem	log.cc	/^    ThreadIdFormatItem(const std::string&str=""){}$/;"	f	class:JKYi::ThreadIdFormatItem	access:public	signature:(const std::string&str=”)
JKYi::ThreadNameFormatItem	log.cc	/^class ThreadNameFormatItem: public LogFormatter::FormatItem {$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
JKYi::ThreadNameFormatItem::ThreadNameFormatItem	log.cc	/^    ThreadNameFormatItem(const std::string& str = "") {}$/;"	f	class:JKYi::ThreadNameFormatItem	access:public	signature:(const std::string& str = ”)
JKYi::Timer	timer.h	/^class Timer:public std::enable_shared_from_this<Timer>{$/;"	c	namespace:JKYi	inherits:std::enable_shared_from_this
JKYi::Timer::Comparator	timer.h	/^   struct Comparator{$/;"	s	class:JKYi::Timer	access:private
JKYi::Timer::Comparator::operator ()	timer.cc	/^bool Timer::Comparator::operator()(const Timer::ptr &lhv,$/;"	f	class:JKYi::Timer::Comparator	signature:(const Timer::ptr &lhv, const Timer::ptr&rhv) const
JKYi::Timer::Comparator::operator ()	timer.h	/^     bool operator()(const Timer::ptr&lhv,const Timer::ptr &rhv)const;$/;"	p	struct:JKYi::Timer::Comparator	access:public	signature:(const Timer::ptr&lhv,const Timer::ptr &rhv) const
JKYi::Timer::Timer	timer.cc	/^Timer::Timer(uint64_t ms,std::function<void ()>cb,bool recurring,TimerManager*manager)$/;"	f	class:JKYi::Timer	signature:(uint64_t ms,std::function<void ()>cb,bool recurring,TimerManager*manager)
JKYi::Timer::Timer	timer.cc	/^Timer::Timer(uint64_t next)$/;"	f	class:JKYi::Timer	signature:(uint64_t next)
JKYi::Timer::Timer	timer.h	/^   Timer(uint64_t ms,std::function<void ()>cb,bool recurring,TimerManager*manager);$/;"	p	class:JKYi::Timer	access:private	signature:(uint64_t ms,std::function<void ()>cb,bool recurring,TimerManager*manager)
JKYi::Timer::Timer	timer.h	/^   Timer(uint64_t next);$/;"	p	class:JKYi::Timer	access:private	signature:(uint64_t next)
JKYi::Timer::cancel	timer.cc	/^bool Timer::cancel(){$/;"	f	class:JKYi::Timer	signature:()
JKYi::Timer::cancel	timer.h	/^   bool cancel();$/;"	p	class:JKYi::Timer	access:public	signature:()
JKYi::Timer::m_cb	timer.h	/^   std::function<void()>m_cb;$/;"	m	class:JKYi::Timer	access:private
JKYi::Timer::m_manager	timer.h	/^   TimerManager* m_manager=nullptr;$/;"	m	class:JKYi::Timer	access:private
JKYi::Timer::m_ms	timer.h	/^   uint64_t m_ms=0;$/;"	m	class:JKYi::Timer	access:private
JKYi::Timer::m_next	timer.h	/^   uint64_t m_next=0;$/;"	m	class:JKYi::Timer	access:private
JKYi::Timer::m_recurring	timer.h	/^   bool m_recurring=false;$/;"	m	class:JKYi::Timer	access:private
JKYi::Timer::ptr	timer.h	/^   typedef std::shared_ptr<Timer> ptr;$/;"	t	class:JKYi::Timer	access:public
JKYi::Timer::refresh	timer.cc	/^bool Timer::refresh(){$/;"	f	class:JKYi::Timer	signature:()
JKYi::Timer::refresh	timer.h	/^   bool refresh();$/;"	p	class:JKYi::Timer	access:public	signature:()
JKYi::Timer::reset	timer.cc	/^bool Timer::reset(uint64_t ms,bool from_now){$/;"	f	class:JKYi::Timer	signature:(uint64_t ms,bool from_now)
JKYi::Timer::reset	timer.h	/^   bool reset(uint64_t ms,bool from_now);$/;"	p	class:JKYi::Timer	access:public	signature:(uint64_t ms,bool from_now)
JKYi::TimerManager	timer.h	/^class TimerManager{$/;"	c	namespace:JKYi
JKYi::TimerManager::RWMutexType	timer.h	/^   typedef RWMutex RWMutexType;$/;"	t	class:JKYi::TimerManager	access:public
JKYi::TimerManager::TimerManager	timer.cc	/^TimerManager::TimerManager(){$/;"	f	class:JKYi::TimerManager	signature:()
JKYi::TimerManager::TimerManager	timer.h	/^   TimerManager();$/;"	p	class:JKYi::TimerManager	access:public	signature:()
JKYi::TimerManager::addConditionTimer	timer.cc	/^Timer::ptr TimerManager::addConditionTimer(uint64_t ms,std::function<void()>cb,std::weak_ptr<void>weak_cond,bool recurring){$/;"	f	class:JKYi::TimerManager	signature:(uint64_t ms,std::function<void()>cb,std::weak_ptr<void>weak_cond,bool recurring)
JKYi::TimerManager::addConditionTimer	timer.h	/^   Timer::ptr addConditionTimer(uint64_t ms,std::function<void()>cb,std::weak_ptr<void>weak_cond,bool recurring=false);$/;"	p	class:JKYi::TimerManager	access:public	signature:(uint64_t ms,std::function<void()>cb,std::weak_ptr<void>weak_cond,bool recurring=false)
JKYi::TimerManager::addTimer	timer.cc	/^Timer::ptr TimerManager::addTimer(uint64_t ms,std::function<void ()>cb,bool recurring){$/;"	f	class:JKYi::TimerManager	signature:(uint64_t ms,std::function<void ()>cb,bool recurring)
JKYi::TimerManager::addTimer	timer.cc	/^void TimerManager::addTimer(Timer::ptr val,RWMutexType::WriteLock &lock){$/;"	f	class:JKYi::TimerManager	signature:(Timer::ptr val,RWMutexType::WriteLock &lock)
JKYi::TimerManager::addTimer	timer.h	/^   Timer::ptr addTimer(uint64_t ms,std::function<void ()>cb,bool recurring=false);$/;"	p	class:JKYi::TimerManager	access:public	signature:(uint64_t ms,std::function<void ()>cb,bool recurring=false)
JKYi::TimerManager::addTimer	timer.h	/^   void addTimer(Timer::ptr val,RWMutexType::WriteLock &lock);$/;"	p	class:JKYi::TimerManager	access:protected	signature:(Timer::ptr val,RWMutexType::WriteLock &lock)
JKYi::TimerManager::deleteClockRollover	timer.cc	/^bool TimerManager::deleteClockRollover(uint64_t now_ms){$/;"	f	class:JKYi::TimerManager	signature:(uint64_t now_ms)
JKYi::TimerManager::deleteClockRollover	timer.h	/^   bool deleteClockRollover(uint64_t now_ms);$/;"	p	class:JKYi::TimerManager	access:private	signature:(uint64_t now_ms)
JKYi::TimerManager::getNextTimer	timer.cc	/^uint64_t TimerManager::getNextTimer(){$/;"	f	class:JKYi::TimerManager	signature:()
JKYi::TimerManager::getNextTimer	timer.h	/^   uint64_t getNextTimer();$/;"	p	class:JKYi::TimerManager	access:public	signature:()
JKYi::TimerManager::hasTimer	timer.cc	/^bool TimerManager::hasTimer(){$/;"	f	class:JKYi::TimerManager	signature:()
JKYi::TimerManager::hasTimer	timer.h	/^   bool hasTimer();$/;"	p	class:JKYi::TimerManager	access:public	signature:()
JKYi::TimerManager::listExpiredCb	timer.cc	/^void TimerManager::listExpiredCb(std::vector<std::function<void ()>>&cbs){$/;"	f	class:JKYi::TimerManager	signature:(std::vector<std::function<void ()>>&cbs)
JKYi::TimerManager::listExpiredCb	timer.h	/^   void listExpiredCb(std::vector<std::function<void ()>>&cbs);$/;"	p	class:JKYi::TimerManager	access:public	signature:(std::vector<std::function<void ()>>&cbs)
JKYi::TimerManager::m_mutex	timer.h	/^   RWMutexType m_mutex;$/;"	m	class:JKYi::TimerManager	access:private
JKYi::TimerManager::m_previouseTime	timer.h	/^   uint64_t m_previouseTime=0;$/;"	m	class:JKYi::TimerManager	access:private
JKYi::TimerManager::m_tickled	timer.h	/^   bool m_tickled=false;$/;"	m	class:JKYi::TimerManager	access:private
JKYi::TimerManager::m_timers	timer.h	/^   std::set<Timer::ptr,Timer::Comparator>m_timers;$/;"	m	class:JKYi::TimerManager	access:private
JKYi::TimerManager::onTimerInsertedAtFront	timer.h	/^   virtual void onTimerInsertedAtFront()=0;$/;"	p	class:JKYi::TimerManager	access:protected	signature:()
JKYi::TimerManager::~TimerManager	timer.cc	/^TimerManager::~TimerManager(){$/;"	f	class:JKYi::TimerManager	signature:()
JKYi::TimerManager::~TimerManager	timer.h	/^   virtual ~TimerManager(); $/;"	p	class:JKYi::TimerManager	access:public	signature:()
JKYi::UnixAddress	address.h	/^class UnixAddress:public Address{$/;"	c	namespace:JKYi	inherits:Address
JKYi::UnixAddress::UnixAddress	address.h	/^	UnixAddress();$/;"	p	class:JKYi::UnixAddress	access:public	signature:()
JKYi::UnixAddress::UnixAddress	address.h	/^	UnixAddress(const std::string& path);$/;"	p	class:JKYi::UnixAddress	access:public	signature:(const std::string& path)
JKYi::UnixAddress::getPath	address.h	/^	std::string getPath()const;$/;"	p	class:JKYi::UnixAddress	access:public	signature:() const
JKYi::UnixAddress::m_addr	address.h	/^	sockaddr_un m_addr;$/;"	m	class:JKYi::UnixAddress	access:private
JKYi::UnixAddress::m_length	address.h	/^	socklen_t m_length;$/;"	m	class:JKYi::UnixAddress	access:private
JKYi::UnixAddress::override	address.h	/^	const sockaddr* getAddr()const override;$/;"	m	class:JKYi::UnixAddress	access:public
JKYi::UnixAddress::override	address.h	/^	sockaddr* getAddr()override;$/;"	m	class:JKYi::UnixAddress	access:public
JKYi::UnixAddress::override	address.h	/^	socklen_t getAddrLen()const override;$/;"	m	class:JKYi::UnixAddress	access:public
JKYi::UnixAddress::override	address.h	/^	std::ostream& insert(std::ostream&os)const override;$/;"	m	class:JKYi::UnixAddress	access:public
JKYi::UnixAddress::ptr	address.h	/^	typedef std::shared_ptr<UnixAddress> ptr;$/;"	t	class:JKYi::UnixAddress	access:public
JKYi::UnixAddress::setAddrLen	address.h	/^	void setAddrLen(uint32_t v);$/;"	p	class:JKYi::UnixAddress	access:public	signature:(uint32_t v)
JKYi::UnknowAddress	address.h	/^class UnknowAddress:public Address{$/;"	c	namespace:JKYi	inherits:Address
JKYi::UnknowAddress::UnknowAddress	address.h	/^	UnknowAddress(const sockaddr&addr);$/;"	p	class:JKYi::UnknowAddress	access:public	signature:(const sockaddr&addr)
JKYi::UnknowAddress::UnknowAddress	address.h	/^	UnknowAddress(int family);$/;"	p	class:JKYi::UnknowAddress	access:public	signature:(int family)
JKYi::UnknowAddress::m_addr	address.h	/^	sockaddr m_addr;$/;"	m	class:JKYi::UnknowAddress	access:private
JKYi::UnknowAddress::override	address.h	/^	const sockaddr* getAddr()const override;$/;"	m	class:JKYi::UnknowAddress	access:public
JKYi::UnknowAddress::override	address.h	/^	sockaddr* getAddr()override;$/;"	m	class:JKYi::UnknowAddress	access:public
JKYi::UnknowAddress::override	address.h	/^	std::ostream& insert(std::ostream&os)const override;$/;"	m	class:JKYi::UnknowAddress	access:public
JKYi::UnknowAddress::override	address.h	/^    socklen_t getAddrLen()override;$/;"	m	class:JKYi::UnknowAddress	access:public
JKYi::UnknowAddress::ptr	address.h	/^	typedef std::shared_ptr<UnknowAddress> ptr;$/;"	t	class:JKYi::UnknowAddress	access:public
JKYi::WriteScopedLockImpl	mutex.h	/^class WriteScopedLockImpl{$/;"	c	namespace:JKYi
JKYi::WriteScopedLockImpl::WriteScopedLockImpl	mutex.h	/^  WriteScopedLockImpl(T&mutex)$/;"	f	class:JKYi::WriteScopedLockImpl	access:public	signature:(T&mutex)
JKYi::WriteScopedLockImpl::lock	mutex.h	/^  void lock(){$/;"	f	class:JKYi::WriteScopedLockImpl	access:public	signature:()
JKYi::WriteScopedLockImpl::m_locked	mutex.h	/^  bool m_locked;$/;"	m	class:JKYi::WriteScopedLockImpl	access:private
JKYi::WriteScopedLockImpl::m_mutex	mutex.h	/^  T& m_mutex;$/;"	m	class:JKYi::WriteScopedLockImpl	access:private
JKYi::WriteScopedLockImpl::unlock	mutex.h	/^  void unlock(){$/;"	f	class:JKYi::WriteScopedLockImpl	access:public	signature:()
JKYi::WriteScopedLockImpl::~WriteScopedLockImpl	mutex.h	/^  ~WriteScopedLockImpl(){$/;"	f	class:JKYi::WriteScopedLockImpl	access:public	signature:()
JKYi::_HookIniter	hook.cc	/^struct _HookIniter{$/;"	s	namespace:JKYi	file:
JKYi::_HookIniter::_HookIniter	hook.cc	/^   _HookIniter(){$/;"	f	struct:JKYi::_HookIniter	access:public	signature:()
JKYi::_log_init	log.cc	/^static LogIniter _log_init;\/\/ÂÖ®Â±ÄÂØπË±°$/;"	m	namespace:JKYi	file:
JKYi::byteswap	endian.h	/^typename std::enable_if<sizeof(T)==sizeof(uint16_t),T>::type byteswap(T value){$/;"	f	namespace:JKYi	signature:(T value)
JKYi::byteswap	endian.h	/^typename std::enable_if<sizeof(T)==sizeof(uint32_t),T>::type byteswap(T value){$/;"	f	namespace:JKYi	signature:(T value)
JKYi::byteswap	endian.h	/^typename std::enable_if<sizeof(T)==sizeof(uint64_t),T>::type byteswap(T value){$/;"	f	namespace:JKYi	signature:(T value)
JKYi::g_fiber_stack_size	fiber.cc	/^ static ConfigVar<uint32_t>::ptr g_fiber_stack_size=JKYi::Config::Lookup<uint32_t>("fiber.stack_size",1024*1024,"fiber stack size");$/;"	m	namespace:JKYi	file:
JKYi::g_log_defines	log.cc	/^JKYi::ConfigVar<std::set<LogDefine>>::ptr g_log_defines=JKYi::Config::Lookup("logs",std::set<LogDefine>(),"logs config");$/;"	m	namespace:JKYi	file:
JKYi::g_logger	fiber.cc	/^ static JKYi::Logger::ptr g_logger=JKYI_LOG_NAME("system");$/;"	m	namespace:JKYi	file:
JKYi::g_logger	iomanager.cc	/^static Logger::ptr g_logger=JKYI_LOG_NAME("system");$/;"	m	namespace:JKYi	file:
JKYi::g_logger	scheduler.cc	/^static Logger::ptr g_logger=JKYI_LOG_NAME("system"); $/;"	m	namespace:JKYi	file:
JKYi::g_logger	thread.cc	/^static JKYi::Logger::ptr g_logger=JKYI_LOG_NAME("system");$/;"	m	namespace:JKYi	file:
JKYi::g_logger	timer.cc	/^Logger::ptr g_logger=JKYI_LOG_NAME("system");$/;"	m	namespace:JKYi	file:
JKYi::g_logger	util.cc	/^static JKYi::Logger::ptr g_logger=JKYI_LOG_NAME("system");$/;"	m	namespace:JKYi	file:
JKYi::g_tcp_connect_timeout	hook.cc	/^static ConfigVar<int>::ptr g_tcp_connect_timeout=Config::Lookup("tcp.connect.timeout",5000,"tcp connect timeout");$/;"	m	namespace:JKYi	file:
JKYi::hook_init	hook.cc	/^void hook_init(){$/;"	f	namespace:JKYi	signature:()
JKYi::is_hook_enable	hook.cc	/^bool is_hook_enable(){$/;"	f	namespace:JKYi	signature:()
JKYi::is_hook_enable	hook.h	/^bool is_hook_enable();$/;"	p	namespace:JKYi	signature:()
JKYi::s_connect_timeout	hook.cc	/^static uint64_t s_connect_timeout=-1;$/;"	m	namespace:JKYi	file:
JKYi::s_hook_initer	hook.cc	/^static _HookIniter s_hook_initer;$/;"	m	namespace:JKYi	file:
JKYi::set_hook_enable	hook.cc	/^void set_hook_enable(bool flag){$/;"	f	namespace:JKYi	signature:(bool flag)
JKYi::set_hook_enable	hook.h	/^void set_hook_enable(bool flag);$/;"	p	namespace:JKYi	signature:(bool flag)
JKYi::t_fiber	fiber.cc	/^ static thread_local Fiber* t_fiber=nullptr;$/;"	m	namespace:JKYi	file:
JKYi::t_hook_enable	hook.cc	/^static thread_local bool t_hook_enable=false;$/;"	m	namespace:JKYi	file:
JKYi::t_scheduler	scheduler.cc	/^static thread_local Scheduler* t_scheduler=nullptr;$/;"	m	namespace:JKYi	file:
JKYi::t_scheduler_fiber	scheduler.cc	/^static thread_local Fiber* t_scheduler_fiber=nullptr;$/;"	m	namespace:JKYi	file:
JKYi::t_thread	thread.cc	/^static thread_local Thread* t_thread=nullptr;$/;"	m	namespace:JKYi	file:
JKYi::t_threadFiber	fiber.cc	/^ static thread_local Fiber::ptr t_threadFiber=nullptr;$/;"	m	namespace:JKYi	file:
JKYi::t_thread_name	thread.cc	/^static thread_local std::string t_thread_name="UNKNOW";$/;"	m	namespace:JKYi	file:
JKYi::toLittleEndian	endian.h	/^T toLittleEndian(T t){$/;"	f	namespace:JKYi	signature:(T t)
JKYi::toNetEndian	endian.h	/^T toNetEndian(T t){$/;"	f	namespace:JKYi	signature:(T t)
Level	log.h	/^   enum Level{$/;"	g	class:JKYi::LogLevel	access:public
LevelFormatItem	log.cc	/^    LevelFormatItem(const std::string&str=""){}$/;"	f	class:JKYi::LevelFormatItem	access:public	signature:(const std::string&str=”)
LevelFormatItem	log.cc	/^class LevelFormatItem:public LogFormatter::FormatItem{$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
LexicalCast	config.h	/^class LexicalCast<std::list<T>,std::string>{$/;"	c	namespace:JKYi
LexicalCast	config.h	/^class LexicalCast<std::map<std::string, T>, std::string> {$/;"	c	namespace:JKYi
LexicalCast	config.h	/^class LexicalCast<std::set<T>,std::string>{$/;"	c	namespace:JKYi
LexicalCast	config.h	/^class LexicalCast<std::string,std::list<T>>{$/;"	c	namespace:JKYi
LexicalCast	config.h	/^class LexicalCast<std::string,std::map<std::string,T>>{$/;"	c	namespace:JKYi
LexicalCast	config.h	/^class LexicalCast<std::string,std::set<T>>{$/;"	c	namespace:JKYi
LexicalCast	config.h	/^class LexicalCast<std::string,std::unordered_map<std::string,T>>{$/;"	c	namespace:JKYi
LexicalCast	config.h	/^class LexicalCast<std::string,std::unordered_set<T>>{$/;"	c	namespace:JKYi
LexicalCast	config.h	/^class LexicalCast<std::string,std::vector<T>>{$/;"	c	namespace:JKYi
LexicalCast	config.h	/^class LexicalCast<std::unordered_map<std::string, T>, std::string> {$/;"	c	namespace:JKYi
LexicalCast	config.h	/^class LexicalCast<std::unordered_set<T>,std::string>{$/;"	c	namespace:JKYi
LexicalCast	config.h	/^class LexicalCast<std::vector<T>,std::string>{$/;"	c	namespace:JKYi
LexicalCast	config.h	/^class LexicalCast{$/;"	c	namespace:JKYi
LexicalCast	log.cc	/^class LexicalCast<LogDefine,std::string>{$/;"	c	namespace:JKYi	file:
LexicalCast	log.cc	/^class LexicalCast<std::string,LogDefine>{$/;"	c	namespace:JKYi	file:
LineFormatItem	log.cc	/^    LineFormatItem(const std::string& str = "") {}$/;"	f	class:JKYi::LineFormatItem	access:public	signature:(const std::string& str = ”)
LineFormatItem	log.cc	/^class LineFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
ListAllMember	config.cc	/^static void ListAllMember(const std::string&prefix,const YAML::Node&node,std::list<std::pair<std::string,const YAML::Node>>&output){$/;"	f	namespace:JKYi	signature:(const std::string&prefix,const YAML::Node&node,std::list<std::pair<std::string,const YAML::Node>>&output)
LoadFromYaml	config.cc	/^void Config::LoadFromYaml(const YAML::Node&node){$/;"	f	class:JKYi::Config	signature:(const YAML::Node&node)
LoadFromYaml	config.h	/^    static void LoadFromYaml(const YAML::Node&node);$/;"	p	class:JKYi::Config	access:public	signature:(const YAML::Node&node)
Lock	mutex.h	/^    typedef ScopedLockImpl<Mutex>  Lock;$/;"	t	class:JKYi::Mutex	access:public
Lock	mutex.h	/^   typedef ScopedLockImpl<SpinLock>   Lock;$/;"	t	class:JKYi::SpinLock	access:public
LogAppender	log.h	/^class LogAppender{$/;"	c	namespace:JKYi
LogAppenderDefine	log.cc	/^struct LogAppenderDefine{$/;"	s	namespace:JKYi	file:
LogDefine	log.cc	/^struct LogDefine{$/;"	s	namespace:JKYi	file:
LogEvent	log.cc	/^LogEvent::LogEvent(std::shared_ptr<Logger>logger$/;"	f	class:JKYi::LogEvent	signature:(std::shared_ptr<Logger>logger ,JKYi::LogLevel::Level level ,const char*file ,int32_t line ,uint32_t elapse ,uint32_t thread_id ,uint32_t fiber_id ,uint32_t time ,const std::string& threadName)
LogEvent	log.h	/^   LogEvent(std::shared_ptr<Logger>logger$/;"	p	class:JKYi::LogEvent	access:public	signature:(std::shared_ptr<Logger>logger ,LogLevel::Level level ,const char*file ,int32_t line ,uint32_t elapse ,uint32_t thread_id ,uint32_t fiber_id ,uint32_t time ,const std::string&threadName)
LogEvent	log.h	/^class LogEvent{$/;"	c	namespace:JKYi
LogEventWrap	log.cc	/^LogEventWrap::LogEventWrap(LogEvent::ptr event)$/;"	f	class:JKYi::LogEventWrap	signature:(LogEvent::ptr event)
LogEventWrap	log.h	/^   LogEventWrap(LogEvent::ptr event);$/;"	p	class:JKYi::LogEventWrap	access:public	signature:(LogEvent::ptr event)
LogEventWrap	log.h	/^class LogEventWrap{$/;"	c	namespace:JKYi
LogFormatter	log.cc	/^LogFormatter::LogFormatter(const std::string&pattern)$/;"	f	class:JKYi::LogFormatter	signature:(const std::string&pattern)
LogFormatter	log.h	/^    LogFormatter(const std::string&pattern);$/;"	p	class:JKYi::LogFormatter	access:public	signature:(const std::string&pattern)
LogFormatter	log.h	/^class LogFormatter{$/;"	c	namespace:JKYi
LogIniter	log.cc	/^    LogIniter(){$/;"	f	struct:JKYi::LogIniter	access:public	signature:()
LogIniter	log.cc	/^struct LogIniter{$/;"	s	namespace:JKYi	file:
LogLevel	log.h	/^class LogLevel{$/;"	c	namespace:JKYi
Logger	log.cc	/^Logger::Logger(const std::string&name)$/;"	f	class:JKYi::Logger	signature:(const std::string&name)
Logger	log.h	/^    Logger(const std::string& name="root");$/;"	p	class:JKYi::Logger	access:public	signature:(const std::string& name=”)
Logger	log.h	/^class Logger:public std::enable_shared_from_this<Logger>{$/;"	c	namespace:JKYi	inherits:std::enable_shared_from_this
LoggerManager	log.cc	/^LoggerManager::LoggerManager(){$/;"	f	class:JKYi::LoggerManager	signature:()
LoggerManager	log.h	/^     LoggerManager();$/;"	p	class:JKYi::LoggerManager	access:public	signature:()
LoggerManager	log.h	/^class LoggerManager{$/;"	c	namespace:JKYi
LoggerMgr	log.h	/^typedef JKYi::Singleton<LoggerManager> LoggerMgr;$/;"	t	namespace:JKYi
Lookup	address.h	/^	static bool Lookup(std::vector<Address::ptr>&result,const std::string&host,int family=AF_INET,int type=0,int protocol);$/;"	p	class:JKYi::Adddress	access:public	signature:(std::vector<Address::ptr>&result,const std::string&host,int family=AF_INET,int type=0,int protocol)
Lookup	config.h	/^    static typename ConfigVar<T>::ptr Lookup(const std::string&name){$/;"	f	class:JKYi::Config	access:public	signature:(const std::string&name)
Lookup	config.h	/^    static typename ConfigVar<T>::ptr Lookup(const std::string&name,$/;"	f	class:JKYi::Config	access:public	signature:(const std::string&name, const T&default_value,const std::string&description=”)
LookupAny	address.h	/^	static Address::ptr LookupAny(const std::string&host,int family=AF_INET,int type=0,int protocol=0);$/;"	p	class:JKYi::Adddress	access:public	signature:(const std::string&host,int family=AF_INET,int type=0,int protocol=0)
LookupAnyIPAddress	address.h	/^	static std::shared_ptr<IPAddress> LookupAnyIPAddress(const std::string&host,int family=AF_INET,int type=0,int protocol=0);$/;"	p	class:JKYi::Adddress	access:public	signature:(const std::string&host,int family=AF_INET,int type=0,int protocol=0)
LookupBase	config.cc	/^ConfigVarBase::ptr Config::LookupBase(const std::string&name){$/;"	f	class:JKYi::Config	signature:(const std::string&name)
LookupBase	config.h	/^    static ConfigVarBase::ptr LookupBase(const std::string&name);$/;"	p	class:JKYi::Config	access:public	signature:(const std::string&name)
MainFunc	fiber.cc	/^void Fiber::MainFunc(){$/;"	f	class:JKYi::Fiber	signature:()
MainFunc	fiber.h	/^   static void MainFunc();$/;"	p	class:JKYi::Fiber	access:public	signature:()
MallocStackAllocator	fiber.cc	/^class MallocStackAllocator{$/;"	c	namespace:JKYi	file:
MessageFormatItem	log.cc	/^   MessageFormatItem(const std::string& str=""){}$/;"	f	class:JKYi::MessageFormatItem	access:public	signature:(const std::string& str=”)
MessageFormatItem	log.cc	/^class MessageFormatItem:public LogFormatter::FormatItem{$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
Mutex	mutex.h	/^   Mutex(){$/;"	f	class:JKYi::Mutex	access:public	signature:()
Mutex	mutex.h	/^class Mutex: Noncopyable{$/;"	c	namespace:JKYi	inherits:Noncopyable
MutexType	iomanager.h	/^     typedef Mutex MutexType;$/;"	t	struct:JKYi::IOManager::FdContext	access:public
MutexType	log.h	/^	typedef SpinLock MutexType;$/;"	t	class:JKYi::LogAppender	access:public
MutexType	log.h	/^	typedef SpinLock MutexType;$/;"	t	class:JKYi::Logger	access:public
MutexType	log.h	/^     typedef SpinLock MutexType;$/;"	t	class:JKYi::LoggerManager	access:public
MutexType	scheduler.h	/^   typedef Mutex MutexType;$/;"	t	class:JKYi::Scheduler	access:public
NONE	iomanager.h	/^	   NONE  =  0x0,$/;"	e	enum:JKYi::IOManager::Event
NameFormatItem	log.cc	/^    NameFormatItem(const std::string&str=""){}$/;"	f	class:JKYi::NameFormatItem	access:public	signature:(const std::string&str=”)
NameFormatItem	log.cc	/^class NameFormatItem:public LogFormatter::FormatItem{$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
NewLineFormatItem	log.cc	/^    NewLineFormatItem(const std::string& str = "") {}$/;"	f	class:JKYi::NewLineFormatItem	access:public	signature:(const std::string& str = ”)
NewLineFormatItem	log.cc	/^class NewLineFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
Noncopyable	noncopyable.h	/^  Noncopyable()=default; $/;"	p	class:JKYi::Noncopyable	access:public	signature:()
Noncopyable	noncopyable.h	/^  Noncopyable(Noncopyable&&)=delete;$/;"	p	class:JKYi::Noncopyable	access:public	signature:(Noncopyable&&)
Noncopyable	noncopyable.h	/^  Noncopyable(const Noncopyable&)=delete;$/;"	p	class:JKYi::Noncopyable	access:public	signature:(const Noncopyable&)
Noncopyable	noncopyable.h	/^class Noncopyable{$/;"	c	namespace:JKYi
OnTimer	timer.cc	/^static void OnTimer(std::weak_ptr<void>weak_cond,std::function<void()>cb){$/;"	f	namespace:JKYi	signature:(std::weak_ptr<void>weak_cond,std::function<void()>cb)
READ	iomanager.h	/^	   READ  =  0x1,$/;"	e	enum:JKYi::IOManager::Event
READY	fiber.h	/^	  READY, \/\/Â∞±Áª™ÊÄÅ$/;"	e	enum:JKYi::Fiber::State
RWMutex	mutex.h	/^    RWMutex(){$/;"	f	class:JKYi::RWMutex	access:public	signature:()
RWMutex	mutex.h	/^class RWMutex:Noncopyable{$/;"	c	namespace:JKYi	inherits:Noncopyable
RWMutexType	config.h	/^	typedef RWMutex RWMutexType;$/;"	t	class:JKYi::Config	access:public
RWMutexType	config.h	/^   typedef RWMutex RWMutexType;$/;"	t	class:JKYi::ConfigVar	access:public
RWMutexType	fdmanager.h	/^    typedef RWMutex RWMutexType;$/;"	t	class:JKYi::FdManager	access:public
RWMutexType	iomanager.h	/^   typedef RWMutex RWMutexType;$/;"	t	class:JKYi::IOManager	access:public
RWMutexType	timer.h	/^   typedef RWMutex RWMutexType;$/;"	t	class:JKYi::TimerManager	access:public
ReadLock	mutex.h	/^    typedef ReadScopedLockImpl<RWMutex> ReadLock;$/;"	t	class:JKYi::RWMutex	access:public
ReadScopedLockImpl	mutex.h	/^  ReadScopedLockImpl(T&mutex)$/;"	f	class:JKYi::ReadScopedLockImpl	access:public	signature:(T&mutex)
ReadScopedLockImpl	mutex.h	/^class ReadScopedLockImpl{$/;"	c	namespace:JKYi
Scheduler	scheduler.cc	/^Scheduler::Scheduler(size_t threads,bool use_caller,const std::string&name)$/;"	f	class:JKYi::Scheduler	signature:(size_t threads,bool use_caller,const std::string&name)
Scheduler	scheduler.h	/^   Scheduler(size_t threads=1,bool use_caller=true,const std::string&name="");$/;"	p	class:JKYi::Scheduler	access:public	signature:(size_t threads=1,bool use_caller=true,const std::string&name=”)
Scheduler	scheduler.h	/^class Scheduler{$/;"	c	namespace:JKYi
ScopedLockImpl	mutex.h	/^  ScopedLockImpl(T&mutex)$/;"	f	class:JKYi::ScopedLockImpl	access:public	signature:(T&mutex)
ScopedLockImpl	mutex.h	/^class ScopedLockImpl{$/;"	c	namespace:JKYi
Semaphore	mutex.cc	/^Semaphore::Semaphore(uint32_t count){$/;"	f	class:JKYi::Semaphore	signature:(uint32_t count)
Semaphore	mutex.h	/^   Semaphore(uint32_t count=0);$/;"	p	class:JKYi::Semaphore	access:public	signature:(uint32_t count=0)
Semaphore	mutex.h	/^class Semaphore:Noncopyable{$/;"	c	namespace:JKYi	inherits:Noncopyable
SetThis	fiber.cc	/^void Fiber::SetThis(Fiber*f){$/;"	f	class:JKYi::Fiber	signature:(Fiber*f)
SetThis	fiber.h	/^   static void SetThis(Fiber*f);$/;"	p	class:JKYi::Fiber	access:public	signature:(Fiber*f)
Singleton	singleton.h	/^class Singleton{$/;"	c	namespace:JKYi
SingletonPtr	singleton.h	/^class SingletonPtr{$/;"	c	namespace:JKYi
SpinLock	mutex.h	/^   SpinLock(){$/;"	f	class:JKYi::SpinLock	access:public	signature:()
SpinLock	mutex.h	/^class SpinLock:Noncopyable{$/;"	c	namespace:JKYi	inherits:Noncopyable
State	fiber.h	/^   enum State{$/;"	g	class:JKYi::Fiber	access:public
StdoutLogAppender	log.h	/^class StdoutLogAppender:public LogAppender{$/;"	c	namespace:JKYi	inherits:LogAppender
StringFormatItem	log.cc	/^   StringFormatItem(const std::string&str)$/;"	f	class:JKYi::StringFormatItem	access:public	signature:(const std::string&str)
StringFormatItem	log.cc	/^class StringFormatItem:public LogFormatter::FormatItem{$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
TERM	fiber.h	/^	  TERM,  \/\/ÁªìÊùüÊÄÅ$/;"	e	enum:JKYi::Fiber::State
TabFormatItem	log.cc	/^   TabFormatItem(const std::string str=""){}$/;"	f	class:JKYi::TabFormatItem	access:public	signature:(const std::string str=”)
TabFormatItem	log.cc	/^class TabFormatItem:public LogFormatter::FormatItem{$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
Thread	thread.cc	/^Thread::Thread(std::function<void()> cb,const std::string &name)$/;"	f	class:JKYi::Thread	signature:(std::function<void()> cb,const std::string &name)
Thread	thread.h	/^   Thread(std::function<void()> cb,const std::string &name); $/;"	p	class:JKYi::Thread	access:public	signature:(std::function<void()> cb,const std::string &name)
Thread	thread.h	/^class Thread:Noncopyable {$/;"	c	namespace:JKYi	inherits:Noncopyable
ThreadIdFormatItem	log.cc	/^    ThreadIdFormatItem(const std::string&str=""){}$/;"	f	class:JKYi::ThreadIdFormatItem	access:public	signature:(const std::string&str=”)
ThreadIdFormatItem	log.cc	/^class ThreadIdFormatItem:public LogFormatter::FormatItem{$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
ThreadNameFormatItem	log.cc	/^    ThreadNameFormatItem(const std::string& str = "") {}$/;"	f	class:JKYi::ThreadNameFormatItem	access:public	signature:(const std::string& str = ”)
ThreadNameFormatItem	log.cc	/^class ThreadNameFormatItem: public LogFormatter::FormatItem {$/;"	c	namespace:JKYi	file:	inherits:LogFormatter::FormatItem
Timer	timer.cc	/^Timer::Timer(uint64_t ms,std::function<void ()>cb,bool recurring,TimerManager*manager)$/;"	f	class:JKYi::Timer	signature:(uint64_t ms,std::function<void ()>cb,bool recurring,TimerManager*manager)
Timer	timer.cc	/^Timer::Timer(uint64_t next)$/;"	f	class:JKYi::Timer	signature:(uint64_t next)
Timer	timer.h	/^   Timer(uint64_t ms,std::function<void ()>cb,bool recurring,TimerManager*manager);$/;"	p	class:JKYi::Timer	access:private	signature:(uint64_t ms,std::function<void ()>cb,bool recurring,TimerManager*manager)
Timer	timer.h	/^   Timer(uint64_t next);$/;"	p	class:JKYi::Timer	access:private	signature:(uint64_t next)
Timer	timer.h	/^class Timer:public std::enable_shared_from_this<Timer>{$/;"	c	namespace:JKYi	inherits:std::enable_shared_from_this
TimerManager	timer.cc	/^TimerManager::TimerManager(){$/;"	f	class:JKYi::TimerManager	signature:()
TimerManager	timer.h	/^   TimerManager();$/;"	p	class:JKYi::TimerManager	access:public	signature:()
TimerManager	timer.h	/^class TimerManager{$/;"	c	namespace:JKYi
ToString	log.cc	/^ const char* LogLevel::ToString(LogLevel::Level level){$/;"	f	class:JKYi::LogLevel	signature:(LogLevel::Level level)
ToString	log.h	/^   static const char* ToString(LogLevel::Level level);$/;"	p	class:JKYi::LogLevel	access:public	signature:(LogLevel::Level level)
TotalFibers	fiber.cc	/^uint64_t Fiber::TotalFibers(){$/;"	f	class:JKYi::Fiber	signature:()
TotalFibers	fiber.h	/^   static uint64_t TotalFibers();$/;"	p	class:JKYi::Fiber	access:public	signature:()
UNKNOW	log.h	/^     UNKNOW=0,$/;"	e	enum:JKYi::LogLevel::Level
UnixAddress	address.h	/^	UnixAddress();$/;"	p	class:JKYi::UnixAddress	access:public	signature:()
UnixAddress	address.h	/^	UnixAddress(const std::string& path);$/;"	p	class:JKYi::UnixAddress	access:public	signature:(const std::string& path)
UnixAddress	address.h	/^class UnixAddress:public Address{$/;"	c	namespace:JKYi	inherits:Address
UnknowAddress	address.h	/^	UnknowAddress(const sockaddr&addr);$/;"	p	class:JKYi::UnknowAddress	access:public	signature:(const sockaddr&addr)
UnknowAddress	address.h	/^	UnknowAddress(int family);$/;"	p	class:JKYi::UnknowAddress	access:public	signature:(int family)
UnknowAddress	address.h	/^class UnknowAddress:public Address{$/;"	c	namespace:JKYi	inherits:Address
Visit	config.cc	/^void Config::Visit(std::function<void (ConfigVarBase::ptr)>cb){$/;"	f	class:JKYi::Config	signature:(std::function<void (ConfigVarBase::ptr)>cb)
Visit	config.h	/^	static void Visit(std::function<void (ConfigVarBase::ptr)>cb); $/;"	p	class:JKYi::Config	access:public	signature:(std::function<void (ConfigVarBase::ptr)>cb)
WARN	log.h	/^     WARN=3,$/;"	e	enum:JKYi::LogLevel::Level
WRITE	iomanager.h	/^	   WRITE =  0x4$/;"	e	enum:JKYi::IOManager::Event
WriteLock	mutex.h	/^	typedef WriteScopedLockImpl<RWMutex> WriteLock;$/;"	t	class:JKYi::RWMutex	access:public
WriteScopedLockImpl	mutex.h	/^  WriteScopedLockImpl(T&mutex)$/;"	f	class:JKYi::WriteScopedLockImpl	access:public	signature:(T&mutex)
WriteScopedLockImpl	mutex.h	/^class WriteScopedLockImpl{$/;"	c	namespace:JKYi
XX	hook.cc	/^    HOOK_FUN(XX);$/;"	v
XX	hook.cc	176;"	d	file:
XX	hook.cc	178;"	d	file:
XX	hook.cc	49;"	d	file:
XX	hook.cc	51;"	d	file:
XX	log.cc	17;"	d	file:
XX	log.cc	27;"	d	file:
XX	log.cc	34;"	d	file:
XX	log.cc	517;"	d	file:
XX	log.cc	52;"	d	file:
XX	log.cc	533;"	d	file:
YieldToHold	fiber.cc	/^void Fiber::YieldToHold(){$/;"	f	class:JKYi::Fiber	signature:()
YieldToHold	fiber.h	/^   static void YieldToHold();$/;"	p	class:JKYi::Fiber	access:public	signature:()
YieldToReady	fiber.cc	/^void Fiber::YieldToReady(){$/;"	f	class:JKYi::Fiber	signature:()
YieldToReady	fiber.h	/^   static void YieldToReady();$/;"	p	class:JKYi::Fiber	access:public	signature:()
_HookIniter	hook.cc	/^   _HookIniter(){$/;"	f	struct:JKYi::_HookIniter	access:public	signature:()
_HookIniter	hook.cc	/^struct _HookIniter{$/;"	s	namespace:JKYi	file:
_JKAI_LOG_H_	log.h	2;"	d
_JKYI_ADDRESS_H_	address.h	2;"	d
_JKYI_CONFIG_H_	config.h	2;"	d
_JKYI_ENDIAN_H_	endian.h	2;"	d
_JKYI_FDMANAGER_H	fdmanager.h	2;"	d
_JKYI_FIBER_H_	fiber.h	2;"	d
_JKYI_HOOK_H_	hook.h	2;"	d
_JKYI_IOMANAGER_H_	iomanager.h	2;"	d
_JKYI_JKYI_H_	JKYi.h	2;"	d
_JKYI_MACRO_H_	macro.h	2;"	d
_JKYI_MUTEX_H_	mutex.h	2;"	d
_JKYI_NONCOPYABLE_H_	noncopyable.h	2;"	d
_JKYI_SCHEDULER_H_	scheduler.h	2;"	d
_JKYI_SINGLETON_H_	singleton.h	2;"	d
_JKYI_THREAD_H_	thread.h	2;"	d
_JKYI_TIMER_H_	timer.h	2;"	d
_JKYI_UTIL_H_	util.h	2;"	d
_log_init	log.cc	/^static LogIniter _log_init;\/\/ÂÖ®Â±ÄÂØπË±°$/;"	m	namespace:JKYi	file:
accept	hook.cc	/^int accept(int s, struct sockaddr *addr, socklen_t *addrlen) {$/;"	f	signature:(int s, struct sockaddr *addr, socklen_t *addrlen)
accept_fun	hook.h	/^typedef int (*accept_fun)(int s, struct sockaddr *addr, socklen_t *addrlen);$/;"	t
addAppender	log.cc	/^void Logger::addAppender(LogAppender::ptr appender){$/;"	f	class:JKYi::Logger	signature:(LogAppender::ptr appender)
addAppender	log.h	/^    void addAppender(LogAppender::ptr appender);$/;"	p	class:JKYi::Logger	access:public	signature:(LogAppender::ptr appender)
addConditionTimer	timer.cc	/^Timer::ptr TimerManager::addConditionTimer(uint64_t ms,std::function<void()>cb,std::weak_ptr<void>weak_cond,bool recurring){$/;"	f	class:JKYi::TimerManager	signature:(uint64_t ms,std::function<void()>cb,std::weak_ptr<void>weak_cond,bool recurring)
addConditionTimer	timer.h	/^   Timer::ptr addConditionTimer(uint64_t ms,std::function<void()>cb,std::weak_ptr<void>weak_cond,bool recurring=false);$/;"	p	class:JKYi::TimerManager	access:public	signature:(uint64_t ms,std::function<void()>cb,std::weak_ptr<void>weak_cond,bool recurring=false)
addEvent	iomanager.cc	/^int IOManager::addEvent(int fd,Event event,std::function<void()>cb){$/;"	f	class:JKYi::IOManager	signature:(int fd,Event event,std::function<void()>cb)
addEvent	iomanager.h	/^   int addEvent(int fd,Event event,std::function<void ()>cb=nullptr);$/;"	p	class:JKYi::IOManager	access:public	signature:(int fd,Event event,std::function<void ()>cb=nullptr)
addListener	config.h	/^   uint64_t addListener(on_change_cb cb){$/;"	f	class:JKYi::ConfigVar	access:public	signature:(on_change_cb cb)
addTimer	timer.cc	/^Timer::ptr TimerManager::addTimer(uint64_t ms,std::function<void ()>cb,bool recurring){$/;"	f	class:JKYi::TimerManager	signature:(uint64_t ms,std::function<void ()>cb,bool recurring)
addTimer	timer.cc	/^void TimerManager::addTimer(Timer::ptr val,RWMutexType::WriteLock &lock){$/;"	f	class:JKYi::TimerManager	signature:(Timer::ptr val,RWMutexType::WriteLock &lock)
addTimer	timer.h	/^   Timer::ptr addTimer(uint64_t ms,std::function<void ()>cb,bool recurring=false);$/;"	p	class:JKYi::TimerManager	access:public	signature:(uint64_t ms,std::function<void ()>cb,bool recurring=false)
addTimer	timer.h	/^   void addTimer(Timer::ptr val,RWMutexType::WriteLock &lock);$/;"	p	class:JKYi::TimerManager	access:protected	signature:(Timer::ptr val,RWMutexType::WriteLock &lock)
appenders	log.cc	/^   std::vector<LogAppenderDefine>appenders;$/;"	m	struct:JKYi::LogDefine	file:	access:public
back	fiber.cc	/^void Fiber::back(){$/;"	f	class:JKYi::Fiber	signature:()
back	fiber.h	/^	void back();$/;"	p	class:JKYi::Fiber	access:public	signature:()
broadcastAddress	address.h	/^	virtual IPAddress::ptr broadcastAddress(uint32_t prefix_len)=0;$/;"	p	class:JKYi::IPAddress	access:public	signature:(uint32_t prefix_len)
byteswap	endian.h	/^typename std::enable_if<sizeof(T)==sizeof(uint16_t),T>::type byteswap(T value){$/;"	f	namespace:JKYi	signature:(T value)
byteswap	endian.h	/^typename std::enable_if<sizeof(T)==sizeof(uint32_t),T>::type byteswap(T value){$/;"	f	namespace:JKYi	signature:(T value)
byteswap	endian.h	/^typename std::enable_if<sizeof(T)==sizeof(uint64_t),T>::type byteswap(T value){$/;"	f	namespace:JKYi	signature:(T value)
call	fiber.cc	/^void Fiber::call(){$/;"	f	class:JKYi::Fiber	signature:()
call	fiber.h	/^	void call();$/;"	p	class:JKYi::Fiber	access:public	signature:()
cancel	timer.cc	/^bool Timer::cancel(){$/;"	f	class:JKYi::Timer	signature:()
cancel	timer.h	/^   bool cancel();$/;"	p	class:JKYi::Timer	access:public	signature:()
cancelAll	iomanager.cc	/^bool IOManager::cancelAll(int fd){$/;"	f	class:JKYi::IOManager	signature:(int fd)
cancelAll	iomanager.h	/^   bool cancelAll(int fd);$/;"	p	class:JKYi::IOManager	access:public	signature:(int fd)
cancelEvent	iomanager.cc	/^bool IOManager::cancelEvent(int fd,Event event){$/;"	f	class:JKYi::IOManager	signature:(int fd,Event event)
cancelEvent	iomanager.h	/^   bool cancelEvent(int fd,Event event);$/;"	p	class:JKYi::IOManager	access:public	signature:(int fd,Event event)
cancelled	hook.cc	/^	int cancelled=0;$/;"	m	struct:timer_info	file:	access:public
cb	iomanager.h	/^	   std::function<void ()>cb;$/;"	m	struct:JKYi::IOManager::FdContext::EventContext	access:public
cb	scheduler.h	/^	 std::function<void ()> cb;$/;"	m	struct:JKYi::Scheduler::FiberAndThread	access:public
clearAppender	log.cc	/^void Logger::clearAppender(){$/;"	f	class:JKYi::Logger	signature:()
clearAppender	log.h	/^    void clearAppender();$/;"	p	class:JKYi::Logger	access:public	signature:()
clearListener	config.h	/^   void clearListener(){$/;"	f	class:JKYi::ConfigVar	access:public	signature:()
close	hook.cc	/^int close(int fd){$/;"	f	signature:(int fd)
close_fun	hook.h	/^typedef int (*close_fun)(int fd);$/;"	t
connect	hook.cc	/^int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen) {$/;"	f	signature:(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
connect_fun	hook.h	/^typedef int (*connect_fun)(int sockfd, const struct sockaddr *addr, socklen_t addrlen);$/;"	t
connect_with_timeout	hook.cc	/^int connect_with_timeout(int socketfd,const struct sockaddr*addr,socklen_t addrlen,uint64_t timeout_ms){$/;"	f	signature:(int socketfd,const struct sockaddr*addr,socklen_t addrlen,uint64_t timeout_ms)
connect_with_timeout	hook.h	/^extern int connect_with_timeout(int fd, const struct sockaddr* addr, socklen_t addrlen, uint64_t timeout_ms);$/;"	p	signature:(int fd, const struct sockaddr* addr, socklen_t addrlen, uint64_t timeout_ms)
contextResize	iomanager.cc	/^void IOManager::contextResize(size_t size){$/;"	f	class:JKYi::IOManager	signature:(size_t size)
contextResize	iomanager.h	/^   void contextResize(size_t size);$/;"	p	class:JKYi::IOManager	access:protected	signature:(size_t size)
debug	log.cc	/^void Logger::debug(LogEvent::ptr event){$/;"	f	class:JKYi::Logger	signature:(LogEvent::ptr event)
debug	log.h	/^    void debug(LogEvent::ptr event);\/\/ËæìÂá∫debugÁ∫ßÂà´ÁöÑÊó•Âøó$/;"	p	class:JKYi::Logger	access:public	signature:(LogEvent::ptr event)
del	fdmanager.cc	/^void FdManager::del(int fd){$/;"	f	class:JKYi::FdManager	signature:(int fd)
del	fdmanager.h	/^	void del(int fd);$/;"	p	class:JKYi::FdManager	access:public	signature:(int fd)
delAppender	log.cc	/^void Logger::delAppender(LogAppender::ptr appender){$/;"	f	class:JKYi::Logger	signature:(LogAppender::ptr appender)
delAppender	log.h	/^    void delAppender(LogAppender::ptr appender);$/;"	p	class:JKYi::Logger	access:public	signature:(LogAppender::ptr appender)
delEvent	iomanager.cc	/^bool IOManager::delEvent(int fd,Event event){$/;"	f	class:JKYi::IOManager	signature:(int fd,Event event)
delEvent	iomanager.h	/^   bool delEvent(int fd,Event event);$/;"	p	class:JKYi::IOManager	access:public	signature:(int fd,Event event)
delListener	config.h	/^   void delListener(uint64_t key){$/;"	f	class:JKYi::ConfigVar	access:public	signature:(uint64_t key)
deleteClockRollover	timer.cc	/^bool TimerManager::deleteClockRollover(uint64_t now_ms){$/;"	f	class:JKYi::TimerManager	signature:(uint64_t now_ms)
deleteClockRollover	timer.h	/^   bool deleteClockRollover(uint64_t now_ms);$/;"	p	class:JKYi::TimerManager	access:private	signature:(uint64_t now_ms)
do_io	hook.cc	/^static ssize_t do_io(int fd,OriginFun&fun,const char * hook_fun_name,uint32_t event,int timeout_so,Args&&...args){$/;"	f	file:	signature:(int fd,OriginFun&fun,const char * hook_fun_name,uint32_t event,int timeout_so,Args&&...args)
error	log.cc	/^void Logger::error(LogEvent::ptr event){$/;"	f	class:JKYi::Logger	signature:(LogEvent::ptr event)
error	log.h	/^    void error(LogEvent::ptr event);$/;"	p	class:JKYi::Logger	access:public	signature:(LogEvent::ptr event)
events	iomanager.h	/^	 Event events=NONE;$/;"	m	struct:JKYi::IOManager::FdContext	access:public
fatal	log.cc	/^void Logger::fatal(LogEvent::ptr event){$/;"	f	class:JKYi::Logger	signature:(LogEvent::ptr event)
fatal	log.h	/^    void fatal(LogEvent::ptr event);$/;"	p	class:JKYi::Logger	access:public	signature:(LogEvent::ptr event)
fcntl	hook.cc	/^int fcntl(int fd,int cmd,...){$/;"	f	signature:(int fd,int cmd,...)
fcntl_fun	hook.h	/^typedef int (*fcntl_fun)(int fd, int cmd, ... \/* arg *\/ );$/;"	t
fd	iomanager.h	/^	 int fd=0;$/;"	m	struct:JKYi::IOManager::FdContext	access:public
fiber	iomanager.h	/^	   Fiber::ptr fiber;$/;"	m	struct:JKYi::IOManager::FdContext::EventContext	access:public
fiber	scheduler.h	/^     Fiber::ptr fiber; $/;"	m	struct:JKYi::Scheduler::FiberAndThread	access:public
file	log.cc	/^    std::string file;$/;"	m	struct:JKYi::LogAppenderDefine	file:	access:public
format	log.cc	/^std::string LogFormatter::format(std::shared_ptr<Logger>logger,LogLevel::Level level,LogEvent::ptr event){$/;"	f	class:JKYi::LogFormatter	signature:(std::shared_ptr<Logger>logger,LogLevel::Level level,LogEvent::ptr event)
format	log.h	/^       virtual void format(std::ostream&os,std::shared_ptr<Logger>logger,LogLevel::Level level,LogEvent::ptr event)=0;$/;"	p	class:JKYi::LogFormatter::FormatItem	access:public	signature:(std::ostream&os,std::shared_ptr<Logger>logger,LogLevel::Level level,LogEvent::ptr event)
format	log.h	/^    std::string format(std::shared_ptr<Logger>logger,LogLevel::Level level,LogEvent::ptr event);$/;"	p	class:JKYi::LogFormatter	access:public	signature:(std::shared_ptr<Logger>logger,LogLevel::Level level,LogEvent::ptr event)
formatter	log.cc	/^    std::string formatter;$/;"	m	struct:JKYi::LogAppenderDefine	file:	access:public
formatter	log.cc	/^   std::string formatter;$/;"	m	struct:JKYi::LogDefine	file:	access:public
fromString	config.h	/^   virtual bool fromString(const std::string&val)=0;$/;"	p	class:JKYi::ConfigVarBase	access:public	signature:(const std::string&val)
g_fiber_stack_size	fiber.cc	/^ static ConfigVar<uint32_t>::ptr g_fiber_stack_size=JKYi::Config::Lookup<uint32_t>("fiber.stack_size",1024*1024,"fiber stack size");$/;"	m	namespace:JKYi	file:
g_log_defines	log.cc	/^JKYi::ConfigVar<std::set<LogDefine>>::ptr g_log_defines=JKYi::Config::Lookup("logs",std::set<LogDefine>(),"logs config");$/;"	m	namespace:JKYi	file:
g_logger	fiber.cc	/^ static JKYi::Logger::ptr g_logger=JKYI_LOG_NAME("system");$/;"	m	namespace:JKYi	file:
g_logger	hook.cc	/^JKYi::Logger::ptr g_logger=JKYI_LOG_NAME("system");$/;"	v
g_logger	iomanager.cc	/^static Logger::ptr g_logger=JKYI_LOG_NAME("system");$/;"	m	namespace:JKYi	file:
g_logger	scheduler.cc	/^static Logger::ptr g_logger=JKYI_LOG_NAME("system"); $/;"	m	namespace:JKYi	file:
g_logger	thread.cc	/^static JKYi::Logger::ptr g_logger=JKYI_LOG_NAME("system");$/;"	m	namespace:JKYi	file:
g_logger	timer.cc	/^Logger::ptr g_logger=JKYI_LOG_NAME("system");$/;"	m	namespace:JKYi	file:
g_logger	util.cc	/^static JKYi::Logger::ptr g_logger=JKYI_LOG_NAME("system");$/;"	m	namespace:JKYi	file:
g_tcp_connect_timeout	hook.cc	/^static ConfigVar<int>::ptr g_tcp_connect_timeout=Config::Lookup("tcp.connect.timeout",5000,"tcp connect timeout");$/;"	m	namespace:JKYi	file:
get	fdmanager.cc	/^FdCtx::ptr FdManager::get(int fd,bool auto_create){$/;"	f	class:JKYi::FdManager	signature:(int fd,bool auto_create)
get	fdmanager.h	/^	FdCtx::ptr get(int fd,bool auto_create=false);$/;"	p	class:JKYi::FdManager	access:public	signature:(int fd,bool auto_create=false)
getAddr	address.h	/^	virtual const sockaddr* getAddr()const=0;$/;"	p	class:JKYi::Adddress	access:public	signature:() const
getAddr	address.h	/^	virtual sockaddr* getAddr()=0;$/;"	p	class:JKYi::Adddress	access:public	signature:()
getAddrLen	address.h	/^	virtual socklen_t getAddrLen()const=0;$/;"	p	class:JKYi::Adddress	access:public	signature:() const
getContent	log.h	/^   std::string getContent() const{return m_ss.str();}$/;"	f	class:JKYi::LogEvent	access:public	signature:() const
getContext	iomanager.cc	/^IOManager::FdContext::EventContext& IOManager::FdContext::getContext(IOManager::Event event){$/;"	f	class:JKYi::IOManager::FdContext	signature:(IOManager::Event event)
getContext	iomanager.h	/^	 EventContext& getContext(Event event);$/;"	p	struct:JKYi::IOManager::FdContext	access:public	signature:(Event event)
getDatas	config.h	/^    static ConfigVarMap& getDatas(){$/;"	f	class:JKYi::Config	access:private	signature:()
getDescription	config.h	/^   const std::string& getDescription()const {return m_description;}$/;"	f	class:JKYi::ConfigVarBase	access:public	signature:() const
getElapse	log.h	/^   uint32_t getElapse()const {return m_elapse;}$/;"	f	class:JKYi::LogEvent	access:public	signature:() const
getEvent	log.h	/^   LogEvent::ptr getEvent()const {return m_event;}$/;"	f	class:JKYi::LogEventWrap	access:public	signature:() const
getFamily	address.h	/^	int getFamily()const;$/;"	p	class:JKYi::Adddress	access:public	signature:() const
getFiberId	log.h	/^   uint32_t getFiberId()const {return m_fiberId;}$/;"	f	class:JKYi::LogEvent	access:public	signature:() const
getFile	log.h	/^   const char* getFile()const {return m_file;}$/;"	f	class:JKYi::LogEvent	access:public	signature:() const
getFormatter	log.cc	/^LogFormatter::ptr LogAppender::getFormatter(){$/;"	f	class:JKYi::LogAppender	signature:()
getFormatter	log.cc	/^LogFormatter::ptr Logger::getFormatter(){$/;"	f	class:JKYi::Logger	signature:()
getFormatter	log.h	/^    LogFormatter::ptr getFormatter(); $/;"	p	class:JKYi::LogAppender	access:public	signature:()
getFormatter	log.h	/^    LogFormatter::ptr getFormatter();$/;"	p	class:JKYi::Logger	access:public	signature:()
getId	fiber.h	/^	uint64_t getId()const {return m_id;}$/;"	f	class:JKYi::Fiber	access:public	signature:() const
getId	thread.h	/^   pid_t getId()const{return m_id;}$/;"	f	class:JKYi::Thread	access:public	signature:() const
getInstance	singleton.h	/^    static std::shared_ptr<T> getInstance(){$/;"	f	class:JKYi::SingletonPtr	access:public	signature:()
getLevel	log.h	/^    LogLevel::Level getLevel()const {return m_level;}$/;"	f	class:JKYi::Logger	access:public	signature:() const
getLevel	log.h	/^    LogLevel::Level getLevel(LogLevel::Level level){return m_level;}$/;"	f	class:JKYi::LogAppender	access:public	signature:(LogLevel::Level level)
getLevel	log.h	/^   LogLevel::Level getLevel() const {return m_level;}$/;"	f	class:JKYi::LogEvent	access:public	signature:() const
getLine	log.h	/^   int32_t getLine()const {return m_line;}$/;"	f	class:JKYi::LogEvent	access:public	signature:() const
getListener	config.h	/^   on_change_cb getListener(uint64_t key){$/;"	f	class:JKYi::ConfigVar	access:public	signature:(uint64_t key)
getLogger	log.cc	/^Logger::ptr LoggerManager::getLogger(const std::string&name){$/;"	f	class:JKYi::LoggerManager	signature:(const std::string&name)
getLogger	log.h	/^     Logger::ptr getLogger(const std::string&name);$/;"	p	class:JKYi::LoggerManager	access:public	signature:(const std::string&name)
getLogger	log.h	/^   std::shared_ptr<Logger> getLogger()const {return m_logger;}$/;"	f	class:JKYi::LogEvent	access:public	signature:() const
getMutex	config.h	/^	static RWMutexType& getMutex(){$/;"	f	class:JKYi::Config	access:private	signature:()
getName	config.h	/^   const std::string& getName()const {return m_name;}$/;"	f	class:JKYi::ConfigVarBase	access:public	signature:() const
getName	log.h	/^    std::string getName()const {return m_name;}$/;"	f	class:JKYi::Logger	access:public	signature:() const
getName	scheduler.h	/^   const std::string& getName()const {return m_name;}$/;"	f	class:JKYi::Scheduler	access:public	signature:() const
getName	thread.h	/^   const std::string& getName()const{return m_name;} $/;"	f	class:JKYi::Thread	access:public	signature:() const
getNextTimer	timer.cc	/^uint64_t TimerManager::getNextTimer(){$/;"	f	class:JKYi::TimerManager	signature:()
getNextTimer	timer.h	/^   uint64_t getNextTimer();$/;"	p	class:JKYi::TimerManager	access:public	signature:()
getPath	address.h	/^	std::string getPath()const;$/;"	p	class:JKYi::UnixAddress	access:public	signature:() const
getPattern	log.h	/^    const std::string& getPattern()const{$/;"	f	class:JKYi::LogFormatter	access:public	signature:() const
getPort	address.h	/^	virtual uint32_t getPort()const =0;$/;"	p	class:JKYi::IPAddress	access:public	signature:() const
getRoot	log.h	/^     Logger::ptr getRoot()const {return m_root;}$/;"	f	class:JKYi::LoggerManager	access:public	signature:() const
getSS	log.cc	/^std::stringstream& LogEventWrap::getSS(){$/;"	f	class:JKYi::LogEventWrap	signature:()
getSS	log.h	/^   std::stringstream& getSS() { return m_ss;}$/;"	f	class:JKYi::LogEvent	access:public	signature:()
getSS	log.h	/^   std::stringstream& getSS();$/;"	p	class:JKYi::LogEventWrap	access:public	signature:()
getState	fiber.h	/^	State getState()const{return m_state;}$/;"	f	class:JKYi::Fiber	access:public	signature:() const
getSysNonblock	fdmanager.h	/^   bool getSysNonblock()const {return m_sysNonblock;}$/;"	f	class:JKYi::FdCtx	access:public	signature:() const
getThreadId	log.h	/^   uint32_t getThreadId()const {return m_threadId;}$/;"	f	class:JKYi::LogEvent	access:public	signature:() const
getThreadName	log.h	/^   const std::string& getThreadName()const {return m_threadName;}$/;"	f	class:JKYi::LogEvent	access:public	signature:() const
getTime	log.h	/^   uint32_t getTime()const{return m_time;}$/;"	f	class:JKYi::LogEvent	access:public	signature:() const
getTimeout	fdmanager.cc	/^uint64_t FdCtx::getTimeout(int type){$/;"	f	class:JKYi::FdCtx	signature:(int type)
getTimeout	fdmanager.h	/^   uint64_t getTimeout(int type);$/;"	p	class:JKYi::FdCtx	access:public	signature:(int type)
getType	config.h	/^   virtual std::string getType()const=0;$/;"	p	class:JKYi::ConfigVarBase	access:public	signature:() const
getUserNonblock	fdmanager.h	/^   bool getUserNonblock()const {return m_userNonblock;}$/;"	f	class:JKYi::FdCtx	access:public	signature:() const
getValue	config.h	/^   const T getValue(){$/;"	f	class:JKYi::ConfigVar	access:public	signature:()
getsockopt	hook.cc	/^int getsockopt(int fd,int level,int optname,void * optval,socklen_t* optlen){$/;"	f	signature:(int fd,int level,int optname,void * optval,socklen_t* optlen)
getsockopt_fun	hook.h	/^typedef int (*getsockopt_fun)(int sockfd, int level, int optname, void *optval, socklen_t *optlen);$/;"	t
hasIdleThreads	scheduler.h	/^   bool hasIdleThreads(){return m_idleThreadCount>0;}$/;"	f	class:JKYi::Scheduler	access:protected	signature:()
hasTimer	timer.cc	/^bool TimerManager::hasTimer(){$/;"	f	class:JKYi::TimerManager	signature:()
hasTimer	timer.h	/^   bool hasTimer();$/;"	p	class:JKYi::TimerManager	access:public	signature:()
hook_init	hook.cc	/^void hook_init(){$/;"	f	namespace:JKYi	signature:()
idle	iomanager.cc	/^void IOManager::idle(){$/;"	f	class:JKYi::IOManager	signature:()
idle	scheduler.cc	/^void Scheduler::idle(){$/;"	f	class:JKYi::Scheduler	signature:()
idle	scheduler.h	/^   virtual void idle();$/;"	p	class:JKYi::Scheduler	access:protected	signature:()
info	log.cc	/^void Logger::info(LogEvent::ptr event){$/;"	f	class:JKYi::Logger	signature:(LogEvent::ptr event)
info	log.h	/^    void info(LogEvent::ptr event);$/;"	p	class:JKYi::Logger	access:public	signature:(LogEvent::ptr event)
init	fdmanager.cc	/^bool FdCtx::init(){$/;"	f	class:JKYi::FdCtx	signature:()
init	fdmanager.h	/^   bool init();$/;"	p	class:JKYi::FdCtx	access:private	signature:()
init	log.cc	/^void LogFormatter::init(){$/;"	f	class:JKYi::LogFormatter	signature:()
init	log.cc	/^void LoggerManager::init(){$/;"	f	class:JKYi::LoggerManager	signature:()
init	log.h	/^     void init();$/;"	p	class:JKYi::LoggerManager	access:public	signature:()
init	log.h	/^    void init();$/;"	p	class:JKYi::LogFormatter	access:public	signature:()
insert	address.h	/^	virtual std::ostream& insert(std::ostream& os)const =0;$/;"	p	class:JKYi::Adddress	access:public	signature:(std::ostream& os) const
ioctl	hook.cc	/^int ioctl(int fd,unsigned long int request,...){$/;"	f	signature:(int fd,unsigned long int request,...)
ioctl_fun	hook.h	/^typedef int (*ioctl_fun)(int d, unsigned long int request, ...);$/;"	t
isClose	fdmanager.h	/^   bool isClose()const {return m_isClosed;}$/;"	f	class:JKYi::FdCtx	access:public	signature:() const
isError	log.h	/^    bool isError()const{return m_error;}$/;"	f	class:JKYi::LogFormatter	access:public	signature:() const
isInit	fdmanager.h	/^   bool isInit()const {return m_isInit;}$/;"	f	class:JKYi::FdCtx	access:public	signature:() const
isSocket	fdmanager.h	/^   bool isSocket()const{return m_isSocket;}$/;"	f	class:JKYi::FdCtx	access:public	signature:() const
is_hook_enable	hook.cc	/^bool is_hook_enable(){$/;"	f	namespace:JKYi	signature:()
is_hook_enable	hook.h	/^bool is_hook_enable();$/;"	p	namespace:JKYi	signature:()
join	thread.cc	/^void Thread::join(){$/;"	f	class:JKYi::Thread	signature:()
join	thread.h	/^   void join();$/;"	p	class:JKYi::Thread	access:public	signature:()
level	log.cc	/^    LogLevel::Level level=LogLevel::UNKNOW;$/;"	m	struct:JKYi::LogAppenderDefine	file:	access:public
level	log.cc	/^   LogLevel::Level level=LogLevel::UNKNOW;$/;"	m	struct:JKYi::LogDefine	file:	access:public
listExpiredCb	timer.cc	/^void TimerManager::listExpiredCb(std::vector<std::function<void ()>>&cbs){$/;"	f	class:JKYi::TimerManager	signature:(std::vector<std::function<void ()>>&cbs)
listExpiredCb	timer.h	/^   void listExpiredCb(std::vector<std::function<void ()>>&cbs);$/;"	p	class:JKYi::TimerManager	access:public	signature:(std::vector<std::function<void ()>>&cbs)
lock	mutex.h	/^   void lock(){$/;"	f	class:JKYi::CASLock	access:public	signature:()
lock	mutex.h	/^   void lock(){$/;"	f	class:JKYi::Mutex	access:public	signature:()
lock	mutex.h	/^   void lock(){$/;"	f	class:JKYi::SpinLock	access:public	signature:()
lock	mutex.h	/^  void lock(){$/;"	f	class:JKYi::ReadScopedLockImpl	access:public	signature:()
lock	mutex.h	/^  void lock(){$/;"	f	class:JKYi::ScopedLockImpl	access:public	signature:()
lock	mutex.h	/^  void lock(){$/;"	f	class:JKYi::WriteScopedLockImpl	access:public	signature:()
log	log.cc	/^void FileLogAppender::log(std::shared_ptr<Logger>logger,LogLevel::Level level,LogEvent::ptr event){$/;"	f	class:JKYi::FileLogAppender	signature:(std::shared_ptr<Logger>logger,LogLevel::Level level,LogEvent::ptr event)
log	log.cc	/^void Logger::log(LogLevel::Level level,LogEvent::ptr event){$/;"	f	class:JKYi::Logger	signature:(LogLevel::Level level,LogEvent::ptr event)
log	log.cc	/^void StdoutLogAppender::log(std::shared_ptr<Logger>logger,LogLevel::Level level,LogEvent::ptr event){$/;"	f	class:JKYi::StdoutLogAppender	signature:(std::shared_ptr<Logger>logger,LogLevel::Level level,LogEvent::ptr event)
log	log.h	/^    virtual void log(std::shared_ptr<Logger> logger, LogLevel::Level level, LogEvent::ptr event) = 0;$/;"	p	class:JKYi::LogAppender	access:public	signature:(std::shared_ptr<Logger> logger, LogLevel::Level level, LogEvent::ptr event)
log	log.h	/^    void log(LogLevel::Level level,LogEvent::ptr event);$/;"	p	class:JKYi::Logger	access:public	signature:(LogLevel::Level level,LogEvent::ptr event)
m_activeThreadCount	scheduler.h	/^   std::atomic<size_t> m_activeThreadCount={0};$/;"	m	class:JKYi::Scheduler	access:protected
m_addr	address.h	/^	sockaddr m_addr;$/;"	m	class:JKYi::UnknowAddress	access:private
m_addr	address.h	/^	sockaddr_in m_addr;$/;"	m	class:JKYi::IPv4Address	access:private
m_addr	address.h	/^	sockaddr_in6 m_addr;$/;"	m	class:JKYi::IPv6Address	access:private
m_addr	address.h	/^	sockaddr_un m_addr;$/;"	m	class:JKYi::UnixAddress	access:private
m_appenders	log.h	/^    std::list<LogAppender::ptr>m_appenders;\/\/AppenderÈõÜÂêà$/;"	m	class:JKYi::Logger	access:private
m_autoStop	scheduler.h	/^   bool m_autoStop=false;$/;"	m	class:JKYi::Scheduler	access:protected
m_cb	fiber.h	/^   std::function<void ()>m_cb;$/;"	m	class:JKYi::Fiber	access:private
m_cb	thread.h	/^   std::function<void()>m_cb;$/;"	m	class:JKYi::Thread	access:private
m_cb	timer.h	/^   std::function<void()>m_cb;$/;"	m	class:JKYi::Timer	access:private
m_cbs	config.h	/^   std::unordered_map<uint64_t,on_change_cb>m_cbs;$/;"	m	class:JKYi::ConfigVar	access:private
m_ctx	fiber.h	/^   ucontext_t m_ctx;$/;"	m	class:JKYi::Fiber	access:private
m_datas	fdmanager.h	/^	std::vector<FdCtx::ptr>m_datas;$/;"	m	class:JKYi::FdManager	access:private
m_description	config.h	/^   std::string m_description;$/;"	m	class:JKYi::ConfigVarBase	access:private
m_elapse	log.h	/^   uint32_t m_elapse=0;\/\/Á®ãÂ∫èÂêØÂä®ÂºÄÂßãÂà∞Áé∞Âú®ÁöÑÊØ´ÁßíÊï∞$/;"	m	class:JKYi::LogEvent	access:private
m_epfd	iomanager.h	/^   int m_epfd=0;$/;"	m	class:JKYi::IOManager	access:private
m_error	log.h	/^    bool m_error=false;$/;"	m	class:JKYi::LogFormatter	access:private
m_event	log.h	/^   LogEvent::ptr m_event;$/;"	m	class:JKYi::LogEventWrap	access:private
m_fd	fdmanager.h	/^  int m_fd;$/;"	m	class:JKYi::FdCtx	access:private
m_fdContexts	iomanager.h	/^   std::vector<FdContext*>m_fdContexts;$/;"	m	class:JKYi::IOManager	access:private
m_fiberId	log.h	/^   uint32_t m_fiberId=0;\/\/ÂçèÁ®ãID$/;"	m	class:JKYi::LogEvent	access:private
m_fibers	scheduler.h	/^  std::list<FiberAndThread> m_fibers;$/;"	m	class:JKYi::Scheduler	access:private
m_file	log.h	/^   const char* m_file=nullptr;\/\/ÁõÆÊ†áÊó•ÂøóÊñá‰ª∂ÁöÑÂêçÁß∞$/;"	m	class:JKYi::LogEvent	access:private
m_filename	log.h	/^     std::string m_filename;\/\/Êñá‰ª∂Âêç$/;"	m	class:JKYi::FileLogAppender	access:private
m_filestream	log.h	/^     std::ofstream m_filestream;$/;"	m	class:JKYi::FileLogAppender	access:private
m_format	log.cc	/^    std::string m_format;$/;"	m	class:JKYi::DateTimeFormatItem	file:	access:private
m_formatter	log.h	/^    LogFormatter::ptr m_formatter;\/\/ÂÆö‰πâÊó•ÂøóËæìÂá∫ÁöÑÊ†ºÂºè$/;"	m	class:JKYi::LogAppender	access:protected
m_formatter	log.h	/^    LogFormatter::ptr m_formatter;\/\/Êó•ÂøóÁöÑËæìÂá∫Ê†ºÂºè$/;"	m	class:JKYi::Logger	access:private
m_hasFormatter	log.h	/^    bool m_hasFormatter=false;$/;"	m	class:JKYi::LogAppender	access:protected
m_id	fiber.h	/^   uint64_t m_id=0;$/;"	m	class:JKYi::Fiber	access:private
m_id	thread.h	/^   pid_t m_id=-1;$/;"	m	class:JKYi::Thread	access:private
m_idleThreadCount	scheduler.h	/^   std::atomic<size_t> m_idleThreadCount={0};$/;"	m	class:JKYi::Scheduler	access:protected
m_items	log.h	/^    std::vector<FormatItem::ptr>m_items;$/;"	m	class:JKYi::LogFormatter	access:private
m_lastTime	log.h	/^	 uint64_t m_lastTime=0;\/\/ËÆ∞ÂΩï‰∏ä‰∏ÄÊ¨°ÊâìÂºÄÁöÑÊó∂Èó¥$/;"	m	class:JKYi::FileLogAppender	access:private
m_length	address.h	/^	socklen_t m_length;$/;"	m	class:JKYi::UnixAddress	access:private
m_level	log.h	/^    LogLevel::Level m_level;  \/\/Êó•ÂøóÁöÑÁ∫ßÂà´ÔºåÂè™ÊúâÊª°Ë∂≥Á∫ßÂà´ÁöÑÊó•ÂøóÊâç‰ºöË¢´ËæìÂá∫workSpace\/JKYi\/log.h$/;"	m	class:JKYi::Logger	access:private
m_level	log.h	/^    LogLevel::Level m_level=LogLevel::DEBUG;\/\/ÈªòËÆ§‰∏∫debugÊ®°Âºè$/;"	m	class:JKYi::LogAppender	access:protected
m_level	log.h	/^   LogLevel::Level m_level;$/;"	m	class:JKYi::LogEvent	access:private
m_line	log.h	/^   int32_t m_line=0;\/\/Ë°åÂè∑$/;"	m	class:JKYi::LogEvent	access:private
m_lock	mutex.h	/^   pthread_rwlock_t m_lock;$/;"	m	class:JKYi::RWMutex	access:private
m_locked	mutex.h	/^  bool m_locked;$/;"	m	class:JKYi::ReadScopedLockImpl	access:private
m_locked	mutex.h	/^  bool m_locked;$/;"	m	class:JKYi::ScopedLockImpl	access:private
m_locked	mutex.h	/^  bool m_locked;$/;"	m	class:JKYi::WriteScopedLockImpl	access:private
m_logger	log.h	/^   std::shared_ptr<Logger>m_logger;$/;"	m	class:JKYi::LogEvent	access:private
m_loggers	log.h	/^    std::map<std::string,Logger::ptr>m_loggers;$/;"	m	class:JKYi::LoggerManager	access:private
m_manager	timer.h	/^   TimerManager* m_manager=nullptr;$/;"	m	class:JKYi::Timer	access:private
m_ms	timer.h	/^   uint64_t m_ms=0;$/;"	m	class:JKYi::Timer	access:private
m_mutex	config.h	/^   RWMutexType m_mutex;$/;"	m	class:JKYi::ConfigVar	access:private
m_mutex	fdmanager.h	/^    RWMutexType m_mutex; $/;"	m	class:JKYi::FdManager	access:private
m_mutex	iomanager.h	/^   RWMutexType m_mutex;$/;"	m	class:JKYi::IOManager	access:private
m_mutex	log.h	/^	MutexType m_mutex;$/;"	m	class:JKYi::LogAppender	access:protected
m_mutex	log.h	/^	MutexType m_mutex;$/;"	m	class:JKYi::Logger	access:private
m_mutex	log.h	/^	MutexType m_mutex;$/;"	m	class:JKYi::LoggerManager	access:private
m_mutex	mutex.h	/^   pthread_mutex_t m_mutex;$/;"	m	class:JKYi::Mutex	access:private
m_mutex	mutex.h	/^   pthread_spinlock_t m_mutex;$/;"	m	class:JKYi::SpinLock	access:private
m_mutex	mutex.h	/^   volatile std::atomic_flag m_mutex;$/;"	m	class:JKYi::CASLock	access:private
m_mutex	mutex.h	/^  T& m_mutex;$/;"	m	class:JKYi::ReadScopedLockImpl	access:private
m_mutex	mutex.h	/^  T& m_mutex;$/;"	m	class:JKYi::ScopedLockImpl	access:private
m_mutex	mutex.h	/^  T& m_mutex;$/;"	m	class:JKYi::WriteScopedLockImpl	access:private
m_mutex	scheduler.h	/^   MutexType m_mutex;$/;"	m	class:JKYi::Scheduler	access:private
m_mutex	timer.h	/^   RWMutexType m_mutex;$/;"	m	class:JKYi::TimerManager	access:private
m_name	config.h	/^   std::string m_name;$/;"	m	class:JKYi::ConfigVarBase	access:private
m_name	log.h	/^    std::string m_name;       \/\/Êó•ÂøóÁöÑÂêçÁß∞$/;"	m	class:JKYi::Logger	access:private
m_name	scheduler.h	/^  std::string m_name;$/;"	m	class:JKYi::Scheduler	access:private
m_name	thread.h	/^   std::string m_name;$/;"	m	class:JKYi::Thread	access:private
m_next	timer.h	/^   uint64_t m_next=0;$/;"	m	class:JKYi::Timer	access:private
m_pattern	log.h	/^    std::string m_pattern;$/;"	m	class:JKYi::LogFormatter	access:private
m_pendingEventCount	iomanager.h	/^   std::atomic<size_t>m_pendingEventCount={0};$/;"	m	class:JKYi::IOManager	access:private
m_previouseTime	timer.h	/^   uint64_t m_previouseTime=0;$/;"	m	class:JKYi::TimerManager	access:private
m_recurring	timer.h	/^   bool m_recurring=false;$/;"	m	class:JKYi::Timer	access:private
m_recvTimeout	fdmanager.h	/^  uint64_t m_recvTimeout;$/;"	m	class:JKYi::FdCtx	access:private
m_root	log.h	/^    Logger::ptr m_root;$/;"	m	class:JKYi::Logger	access:private
m_root	log.h	/^    Logger::ptr m_root;$/;"	m	class:JKYi::LoggerManager	access:private
m_rootFiber	scheduler.h	/^  Fiber::ptr m_rootFiber;$/;"	m	class:JKYi::Scheduler	access:private
m_rootThread	scheduler.h	/^   int m_rootThread=0;$/;"	m	class:JKYi::Scheduler	access:protected
m_semaphore	mutex.h	/^   sem_t m_semaphore; $/;"	m	class:JKYi::Semaphore	access:private
m_semaphore	thread.h	/^   Semaphore m_semaphore;$/;"	m	class:JKYi::Thread	access:private
m_sendTimeout	fdmanager.h	/^  uint64_t m_sendTimeout;$/;"	m	class:JKYi::FdCtx	access:private
m_ss	log.h	/^   std::stringstream m_ss;\/\/ÊµÅÔºåÁî®Êù•Â≠òÂÇ®Ë¶ÅËæìÂá∫ÁöÑÊó•Âøó$/;"	m	class:JKYi::LogEvent	access:private
m_stack	fiber.h	/^   void *m_stack=nullptr;$/;"	m	class:JKYi::Fiber	access:private
m_stacksize	fiber.h	/^   uint32_t m_stacksize=0;$/;"	m	class:JKYi::Fiber	access:private
m_state	fiber.h	/^   State m_state=INIT;$/;"	m	class:JKYi::Fiber	access:private
m_stopping	scheduler.h	/^   bool m_stopping=true;$/;"	m	class:JKYi::Scheduler	access:protected
m_string	log.cc	/^   std::string m_string;$/;"	m	class:JKYi::StringFormatItem	file:	access:private
m_string	log.cc	/^   std::string m_string;$/;"	m	class:JKYi::TabFormatItem	file:	access:private
m_thread	thread.h	/^   pthread_t m_thread=0;$/;"	m	class:JKYi::Thread	access:private
m_threadCount	scheduler.h	/^   size_t m_threadCount=0;$/;"	m	class:JKYi::Scheduler	access:protected
m_threadId	log.h	/^   uint32_t m_threadId=0;\/\/Á∫øÁ®ãID$/;"	m	class:JKYi::LogEvent	access:private
m_threadIds	scheduler.h	/^   std::vector<int> m_threadIds;$/;"	m	class:JKYi::Scheduler	access:protected
m_threadName	log.h	/^   std::string m_threadName;$/;"	m	class:JKYi::LogEvent	access:private
m_threads	scheduler.h	/^  std::vector<Thread::ptr> m_threads;$/;"	m	class:JKYi::Scheduler	access:private
m_tickleFds	iomanager.h	/^   int m_tickleFds[2];$/;"	m	class:JKYi::IOManager	access:private
m_tickled	timer.h	/^   bool m_tickled=false;$/;"	m	class:JKYi::TimerManager	access:private
m_time	log.h	/^   uint32_t m_time=0;\/\/Êó∂Èó¥Êà≥$/;"	m	class:JKYi::LogEvent	access:private
m_timers	timer.h	/^   std::set<Timer::ptr,Timer::Comparator>m_timers;$/;"	m	class:JKYi::TimerManager	access:private
m_val	config.h	/^   T m_val;$/;"	m	class:JKYi::ConfigVar	access:private
mutex	iomanager.h	/^	 MutexType mutex;$/;"	m	struct:JKYi::IOManager::FdContext	access:public
name	log.cc	/^   std::string name;$/;"	m	struct:JKYi::LogDefine	file:	access:public
nanosleep	hook.cc	/^int nanosleep(const struct timespec*req,struct timespec *rem){$/;"	f	signature:(const struct timespec*req,struct timespec *rem)
nanosleep_fun	hook.h	/^typedef int (*nanosleep_fun)(const struct timespec *req, struct timespec *rem);$/;"	t
networkAddress	address.h	/^	virtual IPAddress::ptr networkAddress(uint32_t prefix_len)=0;$/;"	p	class:JKYi::IPAddress	access:public	signature:(uint32_t prefix_len)
notify	mutex.cc	/^void Semaphore::notify(){$/;"	f	class:JKYi::Semaphore	signature:()
notify	mutex.h	/^   void notify();$/;"	p	class:JKYi::Semaphore	access:public	signature:()
onTimerInsertedAtFront	iomanager.cc	/^void IOManager::onTimerInsertedAtFront(){$/;"	f	class:JKYi::IOManager	signature:()
onTimerInsertedAtFront	timer.h	/^   virtual void onTimerInsertedAtFront()=0;$/;"	p	class:JKYi::TimerManager	access:protected	signature:()
on_change_cb	config.h	/^   typedef std::function<void (const  T&oldValue,const T&newValue)> on_change_cb;$/;"	t	class:JKYi::ConfigVar	access:public
operator !=	address.h	/^   bool operator!= (const Address&rhv)const;$/;"	p	class:JKYi::Adddress	access:public	signature:(const Address&rhv) const
operator ()	config.h	/^    std::string operator()(const std::map<std::string, T>& v) {$/;"	f	class:JKYi::LexicalCast	access:public	signature:(const std::map<std::string, T>& v)
operator ()	config.h	/^    std::string operator()(const std::unordered_map<std::string, T>& v) {$/;"	f	class:JKYi::LexicalCast	access:public	signature:(const std::unordered_map<std::string, T>& v)
operator ()	config.h	/^   T operator()(const F&f){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(const F&f)
operator ()	config.h	/^   std::list<T> operator()(const std::string&v){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(const std::string&v)
operator ()	config.h	/^   std::map<std::string,T> operator()(const std::string&v){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(const std::string&v)
operator ()	config.h	/^   std::set<T> operator()(const std::string&v){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(const std::string&v)
operator ()	config.h	/^   std::string operator()(std::list<T>&v){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(std::list<T>&v)
operator ()	config.h	/^   std::string operator()(std::set<T>&v){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(std::set<T>&v)
operator ()	config.h	/^   std::string operator()(std::unordered_set<T>&v){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(std::unordered_set<T>&v)
operator ()	config.h	/^   std::string operator()(std::vector<T>&v){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(std::vector<T>&v)
operator ()	config.h	/^   std::unordered_map<std::string,T> operator()(const std::string&v){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(const std::string&v)
operator ()	config.h	/^   std::unordered_set<T> operator()(const std::string&v){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(const std::string&v)
operator ()	config.h	/^   std::vector<T> operator()(const std::string&v){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(const std::string&v)
operator ()	log.cc	/^      LogDefine operator()(const std::string&str){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(const std::string&str)
operator ()	log.cc	/^     std::string operator()(const LogDefine&ld){$/;"	f	class:JKYi::LexicalCast	access:public	signature:(const LogDefine&ld)
operator ()	timer.cc	/^bool Timer::Comparator::operator()(const Timer::ptr &lhv,$/;"	f	class:JKYi::Timer::Comparator	signature:(const Timer::ptr &lhv, const Timer::ptr&rhv) const
operator ()	timer.h	/^     bool operator()(const Timer::ptr&lhv,const Timer::ptr &rhv)const;$/;"	p	struct:JKYi::Timer::Comparator	access:public	signature:(const Timer::ptr&lhv,const Timer::ptr &rhv) const
operator <	address.h	/^   bool operator< (const Address&rhv)const;$/;"	p	class:JKYi::Adddress	access:public	signature:(const Address&rhv) const
operator <	log.cc	/^   bool operator< (const LogDefine&rhv)const{$/;"	f	struct:JKYi::LogDefine	access:public	signature:(const LogDefine&rhv) const
operator =	noncopyable.h	/^  Noncopyable& operator= (const Noncopyable&)=delete;$/;"	p	class:JKYi::Noncopyable	access:public	signature:(const Noncopyable&)
operator =	noncopyable.h	/^  Noncopyable&& operator= (Noncopyable&&)=delete;$/;"	p	class:JKYi::Noncopyable	access:public	signature:(Noncopyable&&)
operator ==	address.h	/^   bool operator== (const Address&rhv)const;$/;"	p	class:JKYi::Adddress	access:public	signature:(const Address&rhv) const
operator ==	log.cc	/^    bool operator== (const LogAppenderDefine&rhv)const {$/;"	f	struct:JKYi::LogAppenderDefine	access:public	signature:(const LogAppenderDefine&rhv) const
operator ==	log.cc	/^   bool operator== (const LogDefine&rhv)const {$/;"	f	struct:JKYi::LogDefine	access:public	signature:(const LogDefine&rhv) const
override	address.h	/^	IPAddress::ptr broadcastAddress(uint32_t prefix_len)override;$/;"	m	class:JKYi::IPv4Address	access:public
override	address.h	/^	IPAddress::ptr broadcastAddress(uint32_t prefix_len)override;$/;"	m	class:JKYi::IPv6Address	access:public
override	address.h	/^	IPAddress::ptr networkAddress(uint32_t prefix_len)override;$/;"	m	class:JKYi::IPv4Address	access:public
override	address.h	/^	IPAddress::ptr networkAddress(uint32_t prefix_len)override;$/;"	m	class:JKYi::IPv6Address	access:public
override	address.h	/^	IPAddress::ptr subnetMask(uint32_t prefix_len)override;$/;"	m	class:JKYi::IPv4Address	access:public
override	address.h	/^	IPAddress::ptr subnetMaskAddress(uint32_t predix_len)override;$/;"	m	class:JKYi::IPv6Address	access:public
override	address.h	/^	const sockaddr* getAddr()const override;$/;"	m	class:JKYi::IPv4Address	access:public
override	address.h	/^	const sockaddr* getAddr()const override;$/;"	m	class:JKYi::IPv6Address	access:public
override	address.h	/^	const sockaddr* getAddr()const override;$/;"	m	class:JKYi::UnixAddress	access:public
override	address.h	/^	const sockaddr* getAddr()const override;$/;"	m	class:JKYi::UnknowAddress	access:public
override	address.h	/^	sockaddr* getAddr()override;$/;"	m	class:JKYi::IPv4Address	access:public
override	address.h	/^	sockaddr* getAddr()override;$/;"	m	class:JKYi::IPv6Address	access:public
override	address.h	/^	sockaddr* getAddr()override;$/;"	m	class:JKYi::UnixAddress	access:public
override	address.h	/^	sockaddr* getAddr()override;$/;"	m	class:JKYi::UnknowAddress	access:public
override	address.h	/^	socklen_t getAddrLen()const override;$/;"	m	class:JKYi::IPv4Address	access:public
override	address.h	/^	socklen_t getAddrLen()const override;$/;"	m	class:JKYi::IPv6Address	access:public
override	address.h	/^	socklen_t getAddrLen()const override;$/;"	m	class:JKYi::UnixAddress	access:public
override	address.h	/^	std::ostream& insert(std::ostream&os)const override;$/;"	m	class:JKYi::IPv4Address	access:public
override	address.h	/^	std::ostream& insert(std::ostream&os)const override;$/;"	m	class:JKYi::IPv6Address	access:public
override	address.h	/^	std::ostream& insert(std::ostream&os)const override;$/;"	m	class:JKYi::UnixAddress	access:public
override	address.h	/^	std::ostream& insert(std::ostream&os)const override;$/;"	m	class:JKYi::UnknowAddress	access:public
override	address.h	/^	uint32_t getPort()const override;$/;"	m	class:JKYi::IPv4Address	access:public
override	address.h	/^	void setPort(uint16_t v)override;$/;"	m	class:JKYi::IPv4Address	access:public
override	address.h	/^	void setPort(uint16_t v)override;$/;"	m	class:JKYi::IPv6Address	access:public
override	address.h	/^    socklen_t getAddrLen()override;$/;"	m	class:JKYi::UnknowAddress	access:public
override	address.h	/^    uint32_t getPort()const override;$/;"	m	class:JKYi::IPv6Address	access:public
override	iomanager.h	/^   bool stopping()override;$/;"	m	class:JKYi::IOManager	access:protected
override	iomanager.h	/^   void idle()override;$/;"	m	class:JKYi::IOManager	access:protected
override	iomanager.h	/^   void onTimerInsertedAtFront()override;$/;"	m	class:JKYi::IOManager	access:protected
override	iomanager.h	/^   void tickle()override;$/;"	m	class:JKYi::IOManager	access:protected
override	log.h	/^     std::string toYamlString()override;$/;"	m	class:JKYi::FileLogAppender	access:public
override	log.h	/^     void log(Logger::ptr logger, LogLevel::Level level, LogEvent::ptr event) override;$/;"	m	class:JKYi::FileLogAppender	access:public
override	log.h	/^    std::string toYamlString()override;$/;"	m	class:JKYi::StdoutLogAppender	access:public
override	log.h	/^    void log(Logger::ptr logger, LogLevel::Level level, LogEvent::ptr event) override;$/;"	m	class:JKYi::StdoutLogAppender	access:public
ptr	address.h	/^	typedef std::shadred_ptr<IPv6Address> ptr;$/;"	t	class:JKYi::IPv6Address	access:public
ptr	address.h	/^	typedef std::shared_ptr<IPAddress> ptr;$/;"	t	class:JKYi::Adddress	access:public
ptr	address.h	/^	typedef std::shared_ptr<IPAddress> ptr;$/;"	t	class:JKYi::IPAddress	access:public
ptr	address.h	/^	typedef std::shared_ptr<IPv4Address> ptr;$/;"	t	class:JKYi::IPv4Address	access:public
ptr	address.h	/^	typedef std::shared_ptr<UnixAddress> ptr;$/;"	t	class:JKYi::UnixAddress	access:public
ptr	address.h	/^	typedef std::shared_ptr<UnknowAddress> ptr;$/;"	t	class:JKYi::UnknowAddress	access:public
ptr	config.h	/^   typedef std::shared_ptr<ConfigVar<T>> ptr;$/;"	t	class:JKYi::ConfigVar	access:public
ptr	config.h	/^   typedef std::shared_ptr<ConfigVarBase> ptr;$/;"	t	class:JKYi::ConfigVarBase	access:public
ptr	fdmanager.h	/^   typedef std::shared_ptr<FdCtx> ptr;$/;"	t	class:JKYi::FdCtx	access:public
ptr	fiber.h	/^   typedef std::shared_ptr<Fiber> ptr;$/;"	t	class:JKYi::Fiber	access:public
ptr	iomanager.h	/^   typedef std::shared_ptr<IOManager> ptr;$/;"	t	class:JKYi::IOManager	access:public
ptr	log.h	/^       typedef std::shared_ptr<FormatItem> ptr;$/;"	t	class:JKYi::LogFormatter::FormatItem	access:public
ptr	log.h	/^     typedef std::shared_ptr<FileLogAppender> ptr;$/;"	t	class:JKYi::FileLogAppender	access:public
ptr	log.h	/^    typedef std::shared_ptr<LogAppender> ptr;$/;"	t	class:JKYi::LogAppender	access:public
ptr	log.h	/^    typedef std::shared_ptr<LogFormatter> ptr;$/;"	t	class:JKYi::LogFormatter	access:public
ptr	log.h	/^    typedef std::shared_ptr<Logger> ptr;$/;"	t	class:JKYi::Logger	access:public
ptr	log.h	/^    typedef std::shared_ptr<StdoutLogAppender> ptr;$/;"	t	class:JKYi::StdoutLogAppender	access:public
ptr	log.h	/^   typedef std::shared_ptr<LogEvent> ptr; $/;"	t	class:JKYi::LogEvent	access:public
ptr	scheduler.h	/^   typedef std::shared_ptr<Scheduler> ptr;$/;"	t	class:JKYi::Scheduler	access:public
ptr	thread.h	/^   typedef std::shared_ptr<Thread> ptr;$/;"	t	class:JKYi::Thread	access:public
ptr	timer.h	/^   typedef std::shared_ptr<Timer> ptr;$/;"	t	class:JKYi::Timer	access:public
rdlock	mutex.h	/^	void rdlock(){$/;"	f	class:JKYi::RWMutex	access:public	signature:()
read	hook.cc	/^ssize_t read(int fd,void *buf,size_t count){$/;"	f	signature:(int fd,void *buf,size_t count)
read	iomanager.h	/^	 EventContext read;$/;"	m	struct:JKYi::IOManager::FdContext	access:public
read_fun	hook.h	/^typedef ssize_t (*read_fun)(int fd, void *buf, size_t count);$/;"	t
readv	hook.cc	/^ssize_t readv(int fd, const struct iovec *iov, int iovcnt) {$/;"	f	signature:(int fd, const struct iovec *iov, int iovcnt)
readv_fun	hook.h	/^typedef ssize_t (*readv_fun)(int fd, const struct iovec *iov, int iovcnt);$/;"	t
recv	hook.cc	/^ssize_t recv(int sockfd, void *buf, size_t len, int flags) {$/;"	f	signature:(int sockfd, void *buf, size_t len, int flags)
recv_fun	hook.h	/^typedef ssize_t (*recv_fun)(int sockfd, void *buf, size_t len, int flags);$/;"	t
recvfrom	hook.cc	/^ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen) {$/;"	f	signature:(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen)
recvfrom_fun	hook.h	/^typedef ssize_t (*recvfrom_fun)(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);$/;"	t
recvmsg	hook.cc	/^ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags) {$/;"	f	signature:(int sockfd, struct msghdr *msg, int flags)
recvmsg_fun	hook.h	/^typedef ssize_t (*recvmsg_fun)(int sockfd, struct msghdr *msg, int flags);$/;"	t
refresh	timer.cc	/^bool Timer::refresh(){$/;"	f	class:JKYi::Timer	signature:()
refresh	timer.h	/^   bool refresh();$/;"	p	class:JKYi::Timer	access:public	signature:()
reopen	log.cc	/^bool FileLogAppender::reopen(){$/;"	f	class:JKYi::FileLogAppender	signature:()
reopen	log.h	/^     bool reopen();\/\/ÈáçÊñ∞ÂØπÊñá‰ª∂ËøõË°åÊâìÂºÄÔºåÊâìÂºÄÊàêÂäüËøîÂõûtrue$/;"	p	class:JKYi::FileLogAppender	access:public	signature:()
reset	fiber.cc	/^void Fiber::reset(std::function<void()>cb){$/;"	f	class:JKYi::Fiber	signature:(std::function<void()>cb)
reset	fiber.h	/^	void reset(std::function<void ()>cb);$/;"	p	class:JKYi::Fiber	access:public	signature:(std::function<void ()>cb)
reset	scheduler.h	/^	 void reset(){$/;"	f	struct:JKYi::Scheduler::FiberAndThread	access:public	signature:()
reset	timer.cc	/^bool Timer::reset(uint64_t ms,bool from_now){$/;"	f	class:JKYi::Timer	signature:(uint64_t ms,bool from_now)
reset	timer.h	/^   bool reset(uint64_t ms,bool from_now);$/;"	p	class:JKYi::Timer	access:public	signature:(uint64_t ms,bool from_now)
resetContext	iomanager.cc	/^void IOManager::FdContext::resetContext(EventContext&ctx){$/;"	f	class:JKYi::IOManager::FdContext	signature:(EventContext&ctx)
resetContext	iomanager.h	/^	 void resetContext(EventContext&ctx);$/;"	p	struct:JKYi::IOManager::FdContext	access:public	signature:(EventContext&ctx)
run	scheduler.cc	/^void Scheduler::run(){$/;"	f	class:JKYi::Scheduler	signature:()
run	scheduler.h	/^   void run();$/;"	p	class:JKYi::Scheduler	access:protected	signature:()
run	thread.cc	/^ void * Thread::run(void*arg){$/;"	f	class:JKYi::Thread	signature:(void*arg)
run	thread.h	/^   static void * run(void*arg);$/;"	p	class:JKYi::Thread	access:private	signature:(void*arg)
s_connect_timeout	hook.cc	/^static uint64_t s_connect_timeout=-1;$/;"	m	namespace:JKYi	file:
s_hook_initer	hook.cc	/^static _HookIniter s_hook_initer;$/;"	m	namespace:JKYi	file:
schedule	scheduler.h	/^   void schedule(FiberOrCb fc,int thread=-1){$/;"	f	class:JKYi::Scheduler	access:public	signature:(FiberOrCb fc,int thread=-1)
schedule	scheduler.h	/^   void schedule(InputIterator begin,InputIterator end){$/;"	f	class:JKYi::Scheduler	access:public	signature:(InputIterator begin,InputIterator end)
scheduleNoLock	scheduler.h	/^   bool scheduleNoLock(FiberOrCb fc,int thread){$/;"	f	class:JKYi::Scheduler	access:private	signature:(FiberOrCb fc,int thread)
scheduler	iomanager.h	/^       Scheduler* scheduler=nullptr;$/;"	m	struct:JKYi::IOManager::FdContext::EventContext	access:public
send	hook.cc	/^ssize_t send(int s, const void *msg, size_t len, int flags) {$/;"	f	signature:(int s, const void *msg, size_t len, int flags)
send_fun	hook.h	/^typedef ssize_t (*send_fun)(int s, const void *msg, size_t len, int flags);$/;"	t
sendmsg	hook.cc	/^ssize_t sendmsg(int s, const struct msghdr *msg, int flags) {$/;"	f	signature:(int s, const struct msghdr *msg, int flags)
sendmsg_fun	hook.h	/^typedef ssize_t (*sendmsg_fun)(int s, const struct msghdr *msg, int flags);$/;"	t
sendto	hook.cc	/^ssize_t sendto(int s, const void *msg, size_t len, int flags, const struct sockaddr *to, socklen_t tolen) {$/;"	f	signature:(int s, const void *msg, size_t len, int flags, const struct sockaddr *to, socklen_t tolen)
sendto_fun	hook.h	/^typedef ssize_t (*sendto_fun)(int s, const void *msg, size_t len, int flags, const struct sockaddr *to, socklen_t tolen);$/;"	t
setAddrLen	address.h	/^	void setAddrLen(uint32_t v);$/;"	p	class:JKYi::UnixAddress	access:public	signature:(uint32_t v)
setFormatter	log.cc	/^void LogAppender::setFormatter(LogFormatter::ptr formatter){$/;"	f	class:JKYi::LogAppender	signature:(LogFormatter::ptr formatter)
setFormatter	log.cc	/^void Logger::setFormatter(LogFormatter::ptr formatter){$/;"	f	class:JKYi::Logger	signature:(LogFormatter::ptr formatter)
setFormatter	log.cc	/^void Logger::setFormatter(const std::string&str){$/;"	f	class:JKYi::Logger	signature:(const std::string&str)
setFormatter	log.h	/^    void setFormatter(LogFormatter::ptr formatter);$/;"	p	class:JKYi::LogAppender	access:public	signature:(LogFormatter::ptr formatter)
setFormatter	log.h	/^    void setFormatter(LogFormatter::ptr formatter);$/;"	p	class:JKYi::Logger	access:public	signature:(LogFormatter::ptr formatter)
setFormatter	log.h	/^    void setFormatter(const std::string &str);$/;"	p	class:JKYi::Logger	access:public	signature:(const std::string &str)
setLevel	log.h	/^    void setLevel(LogLevel::Level level){m_level=level;}$/;"	f	class:JKYi::LogAppender	access:public	signature:(LogLevel::Level level)
setLevel	log.h	/^    void setLevel(LogLevel::Level level){m_level=level;}$/;"	f	class:JKYi::Logger	access:public	signature:(LogLevel::Level level)
setName	thread.cc	/^void Thread::setName(const std::string&name){$/;"	f	class:JKYi::Thread	signature:(const std::string&name)
setName	thread.h	/^   static void setName(const std::string&name);$/;"	p	class:JKYi::Thread	access:public	signature:(const std::string&name)
setPort	address.h	/^	virtual void  setPort(uint16_t v)=0;$/;"	p	class:JKYi::IPAddress	access:public	signature:(uint16_t v)
setSysNonblock	fdmanager.h	/^   void setSysNonblock(bool flag) {m_sysNonblock=flag;}$/;"	f	class:JKYi::FdCtx	access:public	signature:(bool flag)
setThis	scheduler.cc	/^void Scheduler::setThis(){$/;"	f	class:JKYi::Scheduler	signature:()
setThis	scheduler.h	/^   void setThis();$/;"	p	class:JKYi::Scheduler	access:protected	signature:()
setTimeout	fdmanager.cc	/^void FdCtx::setTimeout(int type,uint64_t t){$/;"	f	class:JKYi::FdCtx	signature:(int type,uint64_t t)
setTimeout	fdmanager.h	/^   void setTimeout(int type,uint64_t v);$/;"	p	class:JKYi::FdCtx	access:public	signature:(int type,uint64_t v)
setUserNonblock	fdmanager.h	/^   void setUserNonblock(bool flag){m_userNonblock=flag;}$/;"	f	class:JKYi::FdCtx	access:public	signature:(bool flag)
setValue	config.h	/^   void setValue(const T&t){$/;"	f	class:JKYi::ConfigVar	access:public	signature:(const T&t)
set_hook_enable	hook.cc	/^void set_hook_enable(bool flag){$/;"	f	namespace:JKYi	signature:(bool flag)
set_hook_enable	hook.h	/^void set_hook_enable(bool flag);$/;"	p	namespace:JKYi	signature:(bool flag)
setsockopt	hook.cc	/^int setsockopt(int fd,int level,int optname,const void * optval,socklen_t optlen){$/;"	f	signature:(int fd,int level,int optname,const void * optval,socklen_t optlen)
setsockopt_fun	hook.h	/^typedef int (*setsockopt_fun)(int sockfd, int level, int optname, const void *optval, socklen_t optlen);$/;"	t
sleep	hook.cc	/^unsigned sleep(unsigned int second){$/;"	f	signature:(unsigned int second)
sleep_fun	hook.h	/^typedef unsigned int (*sleep_fun)(unsigned int seconds);$/;"	t
socket	hook.cc	/^int socket(int domain,int type,int protocol){$/;"	f	signature:(int domain,int type,int protocol)
socket_fun	hook.h	/^typedef int (*socket_fun)(int domain, int type, int protocol);$/;"	t
start	scheduler.cc	/^void Scheduler::start(){$/;"	f	class:JKYi::Scheduler	signature:()
start	scheduler.h	/^   void start();$/;"	p	class:JKYi::Scheduler	access:public	signature:()
stop	scheduler.cc	/^void Scheduler::stop(){$/;"	f	class:JKYi::Scheduler	signature:()
stop	scheduler.h	/^   void stop();$/;"	p	class:JKYi::Scheduler	access:public	signature:()
stopping	iomanager.cc	/^bool IOManager::stopping(){$/;"	f	class:JKYi::IOManager	signature:()
stopping	iomanager.cc	/^bool IOManager::stopping(uint64_t &timeout){$/;"	f	class:JKYi::IOManager	signature:(uint64_t &timeout)
stopping	iomanager.h	/^   bool stopping(uint64_t&timeout);$/;"	p	class:JKYi::IOManager	access:protected	signature:(uint64_t&timeout)
stopping	scheduler.cc	/^bool Scheduler::stopping(){$/;"	f	class:JKYi::Scheduler	signature:()
stopping	scheduler.h	/^   virtual bool stopping();$/;"	p	class:JKYi::Scheduler	access:protected	signature:()
subnetMask	address.h	/^	virtual IPAddress::ptr subnetMask(uint32_t prefix_len)=0;$/;"	p	class:JKYi::IPAddress	access:public	signature:(uint32_t prefix_len)
swapIn	fiber.cc	/^void Fiber::swapIn(){$/;"	f	class:JKYi::Fiber	signature:()
swapIn	fiber.h	/^	void swapIn();$/;"	p	class:JKYi::Fiber	access:public	signature:()
swapOut	fiber.cc	/^void Fiber::swapOut(){$/;"	f	class:JKYi::Fiber	signature:()
swapOut	fiber.h	/^	void swapOut();$/;"	p	class:JKYi::Fiber	access:public	signature:()
t_fiber	fiber.cc	/^ static thread_local Fiber* t_fiber=nullptr;$/;"	m	namespace:JKYi	file:
t_hook_enable	hook.cc	/^static thread_local bool t_hook_enable=false;$/;"	m	namespace:JKYi	file:
t_scheduler	scheduler.cc	/^static thread_local Scheduler* t_scheduler=nullptr;$/;"	m	namespace:JKYi	file:
t_scheduler_fiber	scheduler.cc	/^static thread_local Fiber* t_scheduler_fiber=nullptr;$/;"	m	namespace:JKYi	file:
t_thread	thread.cc	/^static thread_local Thread* t_thread=nullptr;$/;"	m	namespace:JKYi	file:
t_threadFiber	fiber.cc	/^ static thread_local Fiber::ptr t_threadFiber=nullptr;$/;"	m	namespace:JKYi	file:
t_thread_name	thread.cc	/^static thread_local std::string t_thread_name="UNKNOW";$/;"	m	namespace:JKYi	file:
thread	scheduler.h	/^	 int thread;$/;"	m	struct:JKYi::Scheduler::FiberAndThread	access:public
tickle	iomanager.cc	/^void IOManager::tickle(){$/;"	f	class:JKYi::IOManager	signature:()
tickle	scheduler.cc	/^void Scheduler::tickle(){$/;"	f	class:JKYi::Scheduler	signature:()
tickle	scheduler.h	/^   virtual void tickle();$/;"	p	class:JKYi::Scheduler	access:protected	signature:()
timer_info	hook.cc	/^struct timer_info{$/;"	s	file:
timer_info::cancelled	hook.cc	/^	int cancelled=0;$/;"	m	struct:timer_info	file:	access:public
toLittleEndian	endian.h	/^T toLittleEndian(T t){$/;"	f	namespace:JKYi	signature:(T t)
toNetEndian	endian.h	/^T toNetEndian(T t){$/;"	f	namespace:JKYi	signature:(T t)
toString	address.h	/^	std::string toString()const;$/;"	p	class:JKYi::Adddress	access:public	signature:() const
toString	config.h	/^   virtual std::string toString()=0;$/;"	p	class:JKYi::ConfigVarBase	access:public	signature:()
toYamlString	log.cc	/^std::string FileLogAppender::toYamlString(){$/;"	f	class:JKYi::FileLogAppender	signature:()
toYamlString	log.cc	/^std::string Logger::toYamlString(){$/;"	f	class:JKYi::Logger	signature:()
toYamlString	log.cc	/^std::string LoggerManager::toYamlString(){$/;"	f	class:JKYi::LoggerManager	signature:()
toYamlString	log.cc	/^std::string StdoutLogAppender::toYamlString(){$/;"	f	class:JKYi::StdoutLogAppender	signature:()
toYamlString	log.h	/^     std::string toYamlString();$/;"	p	class:JKYi::LoggerManager	access:public	signature:()
toYamlString	log.h	/^    std::string toYamlString();$/;"	p	class:JKYi::Logger	access:public	signature:()
toYamlString	log.h	/^    virtual std::string toYamlString()=0;$/;"	p	class:JKYi::LogAppender	access:public	signature:()
triggerEvent	iomanager.cc	/^void IOManager::FdContext::triggerEvent(IOManager::Event event){$/;"	f	class:JKYi::IOManager::FdContext	signature:(IOManager::Event event)
triggerEvent	iomanager.h	/^	 void triggerEvent(Event event);$/;"	p	struct:JKYi::IOManager::FdContext	access:public	signature:(Event event)
type	log.cc	/^    int type=0;\/\/2Ë°®Á§∫StdoutÔºå1Ë°®Á§∫file$/;"	m	struct:JKYi::LogAppenderDefine	file:	access:public
unlock	mutex.h	/^	void unlock(){$/;"	f	class:JKYi::RWMutex	access:public	signature:()
unlock	mutex.h	/^   void unlock(){$/;"	f	class:JKYi::CASLock	access:public	signature:()
unlock	mutex.h	/^   void unlock(){$/;"	f	class:JKYi::Mutex	access:public	signature:()
unlock	mutex.h	/^   void unlock(){$/;"	f	class:JKYi::SpinLock	access:public	signature:()
unlock	mutex.h	/^  void unlock(){$/;"	f	class:JKYi::ReadScopedLockImpl	access:public	signature:()
unlock	mutex.h	/^  void unlock(){$/;"	f	class:JKYi::ScopedLockImpl	access:public	signature:()
unlock	mutex.h	/^  void unlock(){$/;"	f	class:JKYi::WriteScopedLockImpl	access:public	signature:()
usleep	hook.cc	/^int usleep(useconds_t usec){$/;"	f	signature:(useconds_t usec)
usleep_fun	hook.h	/^typedef int (*usleep_fun)(useconds_t usec);$/;"	t
wait	mutex.cc	/^void Semaphore::wait(){$/;"	f	class:JKYi::Semaphore	signature:()
wait	mutex.h	/^   void wait();$/;"	p	class:JKYi::Semaphore	access:public	signature:()
warn	log.cc	/^void Logger::warn(LogEvent::ptr event){$/;"	f	class:JKYi::Logger	signature:(LogEvent::ptr event)
warn	log.h	/^    void warn(LogEvent::ptr event);$/;"	p	class:JKYi::Logger	access:public	signature:(LogEvent::ptr event)
write	hook.cc	/^ssize_t write(int fd, const void *buf, size_t count) {$/;"	f	signature:(int fd, const void *buf, size_t count)
write	iomanager.h	/^	 EventContext write;$/;"	m	struct:JKYi::IOManager::FdContext	access:public
write_fun	hook.h	/^typedef ssize_t (*write_fun)(int fd, const void *buf, size_t count);$/;"	t
writev	hook.cc	/^ssize_t writev(int fd, const struct iovec *iov, int iovcnt) {$/;"	f	signature:(int fd, const struct iovec *iov, int iovcnt)
writev_fun	hook.h	/^typedef ssize_t (*writev_fun)(int fd, const struct iovec *iov, int iovcnt);$/;"	t
wrlock	mutex.h	/^	void wrlock(){$/;"	f	class:JKYi::RWMutex	access:public	signature:()
~Address	address.h	/^	virtual ~Address(){}$/;"	f	class:JKYi::Adddress	access:public	signature:()
~CASLock	mutex.h	/^   ~CASLock(){$/;"	f	class:JKYi::CASLock	access:public	signature:()
~ConfigVarBase	config.h	/^   virtual ~ConfigVarBase(){};\/\/Âõ†‰∏∫Ë¶Å‰Ωú‰∏∫Âü∫Á±ª$/;"	f	class:JKYi::ConfigVarBase	access:public	signature:()
~FdCtx	fdmanager.cc	/^FdCtx::~FdCtx(){$/;"	f	class:JKYi::FdCtx	signature:()
~FdCtx	fdmanager.h	/^   ~FdCtx();$/;"	p	class:JKYi::FdCtx	access:public	signature:()
~FdManager	fdmanager.cc	/^FdManager::~FdManager(){$/;"	f	class:JKYi::FdManager	signature:()
~FdManager	fdmanager.h	/^	~FdManager();$/;"	p	class:JKYi::FdManager	access:public	signature:()
~Fiber	fiber.cc	/^Fiber::~Fiber(){$/;"	f	class:JKYi::Fiber	signature:()
~Fiber	fiber.h	/^	~Fiber();$/;"	p	class:JKYi::Fiber	access:public	signature:()
~FormatItem	log.h	/^       virtual ~FormatItem(){}$/;"	f	class:JKYi::LogFormatter::FormatItem	access:public	signature:()
~IOManager	iomanager.cc	/^IOManager::~IOManager(){$/;"	f	class:JKYi::IOManager	signature:()
~IOManager	iomanager.h	/^   ~IOManager();    $/;"	p	class:JKYi::IOManager	access:public	signature:()
~LogAppender	log.h	/^    virtual ~LogAppender(){};\/\/Áî±‰∫éËØ•Á±ªÈúÄË¶Å‰Ωú‰∏∫Âü∫Á±ªÔºåÊâÄ‰ª•ËøôÈáåÁöÑËØùÂ∞±ÊûêÊûÑÂáΩÊï∞Áî≥Êòé‰∏∫ËôöÂáΩÊï∞ÔºåÈÅøÂÖçÂÜÖÂ≠òÊ≥ÑÊºè$/;"	f	class:JKYi::LogAppender	access:public	signature:()
~LogEventWrap	log.cc	/^LogEventWrap::~LogEventWrap(){$/;"	f	class:JKYi::LogEventWrap	signature:()
~LogEventWrap	log.h	/^   ~LogEventWrap();$/;"	p	class:JKYi::LogEventWrap	access:public	signature:()
~Mutex	mutex.h	/^   ~Mutex(){$/;"	f	class:JKYi::Mutex	access:public	signature:()
~Noncopyable	noncopyable.h	/^  ~Noncopyable()=default;$/;"	p	class:JKYi::Noncopyable	access:public	signature:()
~RWMutex	mutex.h	/^	~RWMutex(){$/;"	f	class:JKYi::RWMutex	access:public	signature:()
~ReadScopedLockImpl	mutex.h	/^  ~ReadScopedLockImpl(){$/;"	f	class:JKYi::ReadScopedLockImpl	access:public	signature:()
~Scheduler	scheduler.cc	/^Scheduler::~Scheduler(){$/;"	f	class:JKYi::Scheduler	signature:()
~Scheduler	scheduler.h	/^   virtual ~Scheduler();$/;"	p	class:JKYi::Scheduler	access:public	signature:()
~ScopedLockImpl	mutex.h	/^  ~ScopedLockImpl(){$/;"	f	class:JKYi::ScopedLockImpl	access:public	signature:()
~Semaphore	mutex.cc	/^Semaphore::~Semaphore(){$/;"	f	class:JKYi::Semaphore	signature:()
~Semaphore	mutex.h	/^   ~Semaphore();$/;"	p	class:JKYi::Semaphore	access:public	signature:()
~SpinLock	mutex.h	/^   ~SpinLock(){$/;"	f	class:JKYi::SpinLock	access:public	signature:()
~Thread	thread.cc	/^Thread::~Thread(){$/;"	f	class:JKYi::Thread	signature:()
~Thread	thread.h	/^   ~Thread(); $/;"	p	class:JKYi::Thread	access:public	signature:()
~TimerManager	timer.cc	/^TimerManager::~TimerManager(){$/;"	f	class:JKYi::TimerManager	signature:()
~TimerManager	timer.h	/^   virtual ~TimerManager(); $/;"	p	class:JKYi::TimerManager	access:public	signature:()
~WriteScopedLockImpl	mutex.h	/^  ~WriteScopedLockImpl(){$/;"	f	class:JKYi::WriteScopedLockImpl	access:public	signature:()
