1.日志系统和配置系统的整合
对于配置系统，在log.yam作用的统一个格式是
logs:
   -name: root
    level: (debug,error,info...)
    formatter: '%d %T %t %T %F %T [%p] %T %f %T %l %T <%m> %n'
    appender: 
      -type: (StdoutAppender,FileAppender)
       level: (debug,info,error...)
       file: /home/admin/workSpace/log.txt
//以上是默认的格式，用户如果需要的话，可以在下面以上面那种方式进行添加或者修改

//2022.5.27
不要在头文件里面写函数的定义，除非将定义放在类里面或者是哟个inline关键字进行修饰，不然的话如果该头文件被多个源文件包含的话，就会造成该函数被编译多次
从而出现函数重定义的问题。
//2022.5.28
如果想要一个类不能够被拷贝的话，我们可以额外定义一个noncopyable的类型，将该类的默认构造和默认析构定义为default，然后将其他的拷贝构造、拷贝赋值、移动构造、移动赋值全部都声明为delete。然后我们将直接让不能够被拷贝的类继承noncopyalbe就行了
//2022.5.29
封装的互斥器不能够用在const成员函数内部，因为他涉及到修改类中的m_mutex这个成员变量，而const成员函数内部不能够修改没有用mutable修饰的成员变量
经测试，在平凡写的情况下下，自旋锁的效率比互斥锁高3-4倍，原子锁和自旋锁效率相当，但是还是考虑使用自旋锁好一点，因为自旋锁在尝试几次抢不到锁之后就会陷入睡眠，而原子锁会在while中一直尝试获取锁，从而使得CPU利用率降低
//2022.5.30
static成员函数中不能够访问类中非static的成员
static成员函数不能够使用const关键字来进行修饰
在宏定义中，表达式一定要使用()将他给括起来,否则非常容易出错！！！！！！！！！！！！
//2022.6.9
类中的非静态成员变量的初始化顺序应该按照他们的声明顺序在构造函数的成员初始化列表中进行初始化，否则编译期会进行警告甚至报错
//2022.6.16
socket在非阻塞的状态下，当调用connect向服务器请求建立连接时，连接可能不会立刻就建立成功，这个时候connect的返回值是-1并且error为EINPROGRESS。这个时候我们需要对该socket的写事件进行监听，如果发生了写事件并且通过getsocketpot检测到错误码是0时才能够确定连接是建立成功的，否则就是失败的
